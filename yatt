#!/usr/bin/env bash

set -euo pipefail

YATT_DIR="$HOME/.yatt"
PROJECTS_DIR="$YATT_DIR/projects"
TRACK_FILE="$HOME/.yatt/tracking.json"

mkdir -p "$PROJECTS_DIR"

# -------------------------------
# Utilities
# -------------------------------
json_read() { jq '.' "$1"; }
json_write() { echo "$2" > "$1"; }

# -------------------------------
# Help
# -------------------------------
help() {
    cat <<EOF
YATT - Yet Another Task Tracker

Usage:
  ./yatt <command> [subcommand] [options]

Commands:

Project management:
  project create <name> <description>       Create a new project
  project remove <name>                      Delete an existing project (asks for confirmation)
  project list                              List projects and modules

Tag management:
  project tags add <project|module@project> <tag>     Add a tag (duplicates prevented)
  project tags remove <project|module@project> <tag>  Remove a tag
  project tags list <project|module@project>         List tags
  project tags by <tag>                              List all projects/submodules with the tag

Submodule management:
  submodule create <name>@<project> <description>   Create a submodule under a project
  submodule remove <name>@<project>                 Remove a submodule

Other:
  help                                      Show this help

Examples:
  ./yatt project create myapp "Main backend project"
  ./yatt submodule create auth@myapp "Authentication service"
  ./yatt project tags add myapp backend
  ./yatt project tags by backend
  ./yatt project delete myapp
EOF
}

# -------------------------------
# Project commands
# -------------------------------
project_create() {
    local name="$1"
    local desc="$2"
    local file="$PROJECTS_DIR/$name.json"
    if [[ -f "$file" ]]; then
        echo "Project '$name' already exists."
        exit 1
    fi

    jq -n --arg n "$name" --arg d "$desc" '{name:$n, description:$d, tags:[], modules:[]}' > "$file"
    echo "‚úÖ Project '$name' created."
}

project_remove() {
    local name="$1"

    [[ -z "$name" ]] && { echo "‚ùå Usage: project remove <name>"; exit 1; }

    local project_file="$PROJECTS_DIR/${name}.json"

    if [[ ! -f "$project_file" ]]; then
        echo "‚ùå Project '$name' not found."
        exit 1
    fi

    # Confirm before deletion
    read -p "‚ö†Ô∏è  Are you sure you want to delete project '$name'? (y/N): " confirm
    [[ "$confirm" =~ ^[Yy]$ ]] || { echo "‚ùå Operation cancelled."; exit 0; }

    rm -f "$project_file"
    echo "üóëÔ∏è  Project '$name' removed."
}

project_list() {
    echo "üìÇ Projects:"
    for f in "$PROJECTS_DIR"/*.json; do
        [[ -f "$f" ]] || continue
        local project
        project=$(basename "$f" .json)
        echo "  - $project"
        local modules
        modules=$(jq -r '.modules[].name?' "$f")
        while IFS= read -r m; do
            [[ -z "$m" ]] && continue
            echo "      * $m"
        done <<< "$modules"
    done
}

# -------------------------------
# Submodule commands
# -------------------------------
submodule_create() {
    local full="$1"
    local desc="$2"
    local module="${full%@*}"
    local parent="${full#*@}"
    local file="$PROJECTS_DIR/$parent.json"

    if [[ ! -f "$file" ]]; then
        echo "Parent project '$parent' does not exist."
        exit 1
    fi

    if jq -e --arg m "$module" '.modules[] | select(.name==$m)' "$file" >/dev/null; then
        echo "Submodule '$module@$parent' already exists."
        exit 1
    fi

    jq --arg m "$module" --arg d "$desc" '.modules += [{"name":$m, "description":$d, "tags":[]}]' "$file" \
       > "$file.tmp" && mv "$file.tmp" "$file"

    echo "‚úÖ Submodule '$module@$parent' created."
}

submodule_remove() {
    local full="$1"
    local module="${full%@*}"
    local parent="${full#*@}"
    local file="$PROJECTS_DIR/$parent.json"

    [[ -f "$file" ]] || { echo "Parent project '$parent' does not exist."; exit 1; }

    jq --arg m "$module" '.modules |= map(select(.name != $m))' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
    echo "‚úÖ Submodule '$module@$parent' removed."
}


# -------------------------------
# Tag commands
# -------------------------------
tags_add() {
    local key="$1"
    local tag="$2"

    if [[ "$key" == *@* ]]; then
        # Submodule
        local module="${key%@*}"
        local parent="${key#*@}"
        local file="$PROJECTS_DIR/$parent.json"
        [[ -f "$file" ]] || { echo "Parent project '$parent' does not exist"; exit 1; }

        local json
        json=$(json_read "$file")

        # Prevent duplicate tag
        if echo "$json" | jq -e --arg m "$module" --arg t "$tag" '.modules[] | select(.name==$m) | .tags | index($t)' >/dev/null; then
            echo "‚úÖ Tag '$tag' already present for submodule '$module@$parent'."
            return
        fi

        json=$(echo "$json" | jq --arg m "$module" --arg t "$tag" '
            .modules |= map(if .name==$m then .tags += [$t] else . end)
        ')
        json_write "$file" "$json"
        echo "‚úÖ Tag '$tag' added to submodule '$module@$parent'."

    else
        # Project
        local file="$PROJECTS_DIR/$key.json"
        [[ -f "$file" ]] || { echo "Project '$key' does not exist"; exit 1; }

        local json
        json=$(json_read "$file")
        if echo "$json" | jq -e --arg t "$tag" '.tags | index($t)' >/dev/null; then
            echo "‚úÖ Tag '$tag' already present for project '$key'."
            return
        fi
        json=$(echo "$json" | jq --arg t "$tag" '.tags += [$t]')
        json_write "$file" "$json"
        echo "‚úÖ Tag '$tag' added to project '$key'."
    fi
}
tags_remove() {
    local key="$1"
    local tag="$2"

    if [[ "$key" == *@* ]]; then
        # Submodule
        local module="${key%@*}"
        local parent="${key#*@}"
        local file="$PROJECTS_DIR/$parent.json"
        [[ -f "$file" ]] || { echo "Parent project '$parent' does not exist"; exit 1; }

        jq --arg m "$module" --arg t "$tag" '
            .modules |= map(
                if .name==$m then .tags |= map(select(. != $t)) else . end
            )
        ' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
        echo "‚úÖ Tag '$tag' removed from submodule '$module@$parent'."

    else
        # Project
        local file="$PROJECTS_DIR/$key.json"
        [[ -f "$file" ]] || { echo "Project '$key' does not exist"; exit 1; }

        jq --arg t "$tag" '.tags |= map(select(. != $t))' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
        echo "‚úÖ Tag '$tag' removed from project '$key'."
    fi
}

tags_list() {
    local key="$1"

    if [[ "$key" == *@* ]]; then
        local module="${key%@*}"
        local parent="${key#*@}"
        local file="$PROJECTS_DIR/$parent.json"
        [[ -f "$file" ]] || { echo "Parent project '$parent' does not exist"; exit 1; }
        json_read "$file" | jq -r --arg m "$module" '.modules[] | select(.name==$m) | .tags[]?'
    else
        local file="$PROJECTS_DIR/$key.json"
        [[ -f "$file" ]] || { echo "Project '$key' does not exist"; exit 1; }
        json_read "$file" | jq -r '.tags[]?'
    fi
}

tags_by() {
    local tag="$1"
    echo "Projects/submodules with tag '$tag':"

    for f in "$PROJECTS_DIR"/*.json; do
        [[ -f "$f" ]] || continue
        local project=$(basename "$f" .json)
        local json
        json=$(json_read "$f")

        # If project has tag
        if echo "$json" | jq -e --arg t "$tag" '.tags | index($t)' >/dev/null; then
            echo "  - $project"
        fi

        # Check modules
        local modules
        modules=$(echo "$json" | jq -c '.modules[]?')
        while IFS= read -r mod; do
            [[ -z "$mod" ]] && continue
            if echo "$mod" | jq -e --arg t "$tag" '.tags | index($t)' >/dev/null; then
                local mod_name
                mod_name=$(echo "$mod" | jq -r '.name')
                echo "      * $mod_name@$project"
            fi
        done <<< "$modules"
    done
}

# -------------------------------
# Tracing
# -------------------------------
ensure_tracking_file() {
    [[ -f "$TRACK_FILE" ]] || echo '{"active": null, "logs": []}' > "$TRACK_FILE"
}

track_start() {
    local name="$1"
    [[ -z "$name" ]] && { echo "‚ùå Usage: yatt track start <project|module@project>"; return 1; }

    ensure_tracking_file

    # Check if active session exists
    if grep -q '"active": {' "$TRACK_FILE"; then
        echo "‚ùå A session is already active. Stop it first with 'yatt track stop'."
        return 1
    fi

    # Check if project exists
    local project_file
    if [[ "$name" == *@* ]]; then
        local parent="${name#*@}"
        project_file="$PROJECTS_DIR/${parent}.json"
        [[ ! -f "$project_file" ]] && { echo "‚ùå Project '$parent' not found."; return 1; }
    else
        project_file="$PROJECTS_DIR/${name}.json"
        [[ ! -f "$project_file" ]] && { echo "‚ùå Project '$name' not found."; return 1; }
    fi

    local start_time
    start_time=$(date -Iseconds)

    # Write active session (don‚Äôt overwrite logs)
    awk -v n="$name" -v t="$start_time" '
        BEGIN { active_written=0 }
        {
            if ($0 ~ /"active": null/) {
                print "  \"active\": {\"name\": \"" n "\", \"start\": \"" t "\"},"
                active_written=1
            } else {
                print
            }
        }
        END {
            if (!active_written) print "  \"active\": {\"name\": \"" n "\", \"start\": \"" t "\"},"
        }
    ' "$TRACK_FILE" > "$TRACK_FILE.tmp" && mv "$TRACK_FILE.tmp" "$TRACK_FILE"

    echo "‚ñ∂Ô∏è Tracking started for '$name' at $start_time"
}

track_stop() {
    ensure_tracking_file

    if ! grep -q '"active": {' "$TRACK_FILE"; then
        echo "‚ùå No active tracking session."
        return 1
    fi

    local name start_time
    name=$(grep -oP '"name": *"\K[^"]+' "$TRACK_FILE")
    start_time=$(grep -oP '"start": *"\K[^"]+' "$TRACK_FILE")

    local end_time
    end_time=$(date -Iseconds)

    local start_epoch end_epoch duration
    start_epoch=$(date -d "$start_time" +%s)
    end_epoch=$(date -d "$end_time" +%s)
    duration=$(( end_epoch - start_epoch ))

    # Clear active section and append to logs
    tmp=$(mktemp)
    {
        echo '{'
        echo '  "active": null,'
        echo '  "logs": ['
        grep -o '{.*}' "$TRACK_FILE" | grep '"logs":' -A9999 | grep -v '"active"' | sed '1d;$d'
        echo "    {\"name\": \"$name\", \"start\": \"$start_time\", \"end\": \"$end_time\", \"duration_sec\": $duration}"
        echo '  ]'
        echo '}'
    } > "$tmp" && mv "$tmp" "$TRACK_FILE"

    echo "‚èπÔ∏è Stopped tracking '$name'. Duration: $((duration / 60)) min $((duration % 60)) sec."
}

track_status() {
    ensure_tracking_file

    # Extract the 'active' object
    local active_line
    active_line=$(grep -oP '"active": *\{[^}]*\}' "$TRACK_FILE")

    # If no active session
    if [[ -z "$active_line" || "$active_line" == *"null"* ]]; then
        echo "üü¢ No active tracking session."
        return 0
    fi

    # Extract name and start timestamp
    local name start_time
    name=$(echo "$active_line" | grep -oP '"name": *"\K[^"]+')
    start_time=$(echo "$active_line" | grep -oP '"start": *"\K[^"]+')

    # Convert start_time to epoch
    local start_epoch now_epoch elapsed
    start_epoch=$(date -d "$start_time" +%s 2>/dev/null) || {
        echo "‚ùå Invalid start timestamp: $start_time"
        return 1
    }
    now_epoch=$(date +%s)
    elapsed=$(( now_epoch - start_epoch ))

    local h=$((elapsed / 3600))
    local m=$(( (elapsed % 3600) / 60 ))
    local s=$((elapsed % 60))

    echo "‚è≥ Tracking: $name"
    echo "   Started:  $start_time"
    echo "   Elapsed:  ${h}h ${m}m ${s}s"
}

# -------------------------------
# Main
# -------------------------------
main() {
    [[ $# -eq 0 ]] && { help; exit 0; }

    local cmd="$1"; shift || true
    case "$cmd" in
        help|-h|--help)
            help
            ;;

        project)
            local sub="$1"; shift || true
            case "$sub" in
                create)
                    project_create "$@"
                    ;;
                remove)
                    project_remove "$@"
                    ;;
                list)
                    project_list
                    ;;
                tags)
                    local tagcmd="$1"; shift || true
                    case "$tagcmd" in
                        add)
                            tags_add "$@"
                            ;;
                        remove)
                            tags_remove "$@"
                            ;;
                        list)
                            tags_list "$@"
                            ;;
                        by)
                            tags_by "$@"
                            ;;
                        search)
                            tags_search_all "$@"
                            ;;
                        *)
                            echo "‚ùå Unknown tag command: $tagcmd"
                            help
                            ;;
                    esac
                    ;;
                *)
                    echo "‚ùå Unknown project subcommand: $sub"
                    help
                    ;;
            esac
            ;;

        track)
            local sub="$1"; shift || true
            case "$sub" in
                start) track_start "$@" ;;
                stop) track_stop ;;
                status) track_status ;;
                log) track_log "$@" ;;
                *) help ;;
            esac
            ;;

        submodule)
            local sub="$1"; shift || true
            case "$sub" in
                create)
                    submodule_create "$@"
                    ;;
                remove)
                    submodule_remove "$@"
                    ;;
                list)
                    submodule_list "$@"
                    ;;
                *)
                    echo "‚ùå Unknown submodule subcommand: $sub"
                    help
                    ;;
            esac
            ;;
        
        *)
            echo "‚ùå Unknown command: $cmd"
            help
            ;;
    esac
}

main "$@"
