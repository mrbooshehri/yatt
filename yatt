#!/usr/bin/env bash

set -euo pipefail

YATT_DIR="$HOME/.yatt"
PROJECTS_DIR="$YATT_DIR/projects"
TRACK_FILE="$HOME/.yatt/tracking.json"

mkdir -p "$YATT_DIR"
mkdir -p "$PROJECTS_DIR"

# -------------------------------
# Utilities
# -------------------------------
json_read() { jq '.' "$1"; }
json_write() { echo "$2" > "$1"; }

color_echo() {
  local color_name="$1"
  local text="$2"

  # Map color names to ANSI color codes
  case "$color_name" in
    black)   color_code="30" ;;
    red)     color_code="31" ;;
    green)   color_code="32" ;;
    yellow)  color_code="33" ;;
    blue)    color_code="34" ;;
    purple|magenta) color_code="35" ;;
    cyan)    color_code="36" ;;
    white)   color_code="37" ;;
    *) echo "Unknown color: $color_name" >&2; return 1 ;;
  esac

  # Print text in color
  echo -e "\033[${color_code}m${text}\033[0m"
}

format_seconds() {
    local T=$1
    local H M S
    H=$((T/3600))
    M=$(( (T%3600)/60 ))
    S=$((T%60))
    printf "%02d:%02d:%02d" $H $M $S
}

# -------------------------------
# Bash Completion Generator
# -------------------------------
generate_completion() {
    cat <<'COMPLETION_EOF'
# Bash completion for yatt
_yatt_completion() {
    local cur prev words cword
    _init_completion || return

    local YATT_DIR="$HOME/.yatt"
    local PROJECTS_DIR="$YATT_DIR/projects"

    # Get list of projects
    _yatt_projects() {
        if [[ -d "$PROJECTS_DIR" ]]; then
            for f in "$PROJECTS_DIR"/*.json; do
                [[ -f "$f" ]] && basename "$f" .json
            done
        fi
    }

    # Get list of submodules for a project
    _yatt_submodules() {
        local project="$1"
        if [[ -f "$PROJECTS_DIR/$project.json" ]]; then
            jq -r '.modules[].name' "$PROJECTS_DIR/$project.json" 2>/dev/null | while read -r mod; do
                echo "$mod@$project"
            done
        fi
    }

    # Get all projects and submodules
    _yatt_all_entities() {
        _yatt_projects
        for proj in $(_yatt_projects); do
            _yatt_submodules "$proj"
        done
    }

    # Get all tags
    _yatt_all_tags() {
        if [[ -d "$PROJECTS_DIR" ]]; then
            for f in "$PROJECTS_DIR"/*.json; do
                [[ -f "$f" ]] && jq -r '.tags[]?, .modules[].tags[]?' "$f" 2>/dev/null
            done | sort -u
        fi
    }

    # Get tags for a specific entity
    _yatt_entity_tags() {
        local entity="$1"
        if [[ "$entity" == *@* ]]; then
            # Submodule
            local module="${entity%@*}"
            local parent="${entity#*@}"
            local file="$PROJECTS_DIR/$parent.json"
            [[ -f "$file" ]] && jq -r --arg m "$module" '.modules[] | select(.name==$m) | .tags[]?' "$file" 2>/dev/null
        else
            # Project
            local file="$PROJECTS_DIR/$entity.json"
            [[ -f "$file" ]] && jq -r '.tags[]?' "$file" 2>/dev/null
        fi
    }

    case $cword in
        1)
            COMPREPLY=($(compgen -W "project submodule track help completion" -- "$cur"))
            ;;
        2)
            case ${words[1]} in
                project)
                    COMPREPLY=($(compgen -W "create remove list tags" -- "$cur"))
                    ;;
                submodule)
                    COMPREPLY=($(compgen -W "create remove list" -- "$cur"))
                    ;;
                track)
                    COMPREPLY=($(compgen -W "start stop status list report" -- "$cur"))
                    ;;
            esac
            ;;
        3)
            case ${words[1]} in
                project)
                    case ${words[2]} in
                        remove)
                            COMPREPLY=($(compgen -W "$(_yatt_projects)" -- "$cur"))
                            ;;
                        tags)
                            COMPREPLY=($(compgen -W "add remove list by" -- "$cur"))
                            ;;
                    esac
                    ;;
                submodule)
                    case ${words[2]} in
                        remove)
                            COMPREPLY=($(compgen -W "$(_yatt_all_entities | grep @)" -- "$cur"))
                            ;;
                        list)
                            COMPREPLY=($(compgen -W "$(_yatt_projects)" -- "$cur"))
                            ;;
                    esac
                    ;;
                track)
                    case ${words[2]} in
                        start)
                            COMPREPLY=($(compgen -W "$(_yatt_all_entities)" -- "$cur"))
                            ;;
                        list|report)
                            local entities=$(_yatt_all_entities)
                            local tags=$(_yatt_all_tags | sed 's/^/tag:/')
                            COMPREPLY=($(compgen -W "$entities $tags" -- "$cur"))
                            ;;
                    esac
                    ;;
            esac
            ;;
        4)
            case ${words[1]} in
                project)
                    case ${words[2]} in
                        tags)
                            case ${words[3]} in
                                add|remove|list)
                                    COMPREPLY=($(compgen -W "$(_yatt_all_entities)" -- "$cur"))
                                    ;;
                                by)
                                    COMPREPLY=($(compgen -W "$(_yatt_all_tags)" -- "$cur"))
                                    ;;
                            esac
                            ;;
                    esac
                    ;;
                track)
                    case ${words[2]} in
                        report)
                            # If previous word is an entity/tag, suggest dates
                            if [[ ${words[3]} != "" ]]; then
                                COMPREPLY=($(compgen -W "$(date +%F) $(date -d yesterday +%F)" -- "$cur"))
                            fi
                            ;;
                    esac
                    ;;
            esac
            ;;
        5)
            case ${words[1]} in
                project)
                    case ${words[2]} in
                        tags)
                            case ${words[3]} in
                                add)
                                    # For add, show all tags as suggestions
                                    COMPREPLY=($(compgen -W "$(_yatt_all_tags)" -- "$cur"))
                                    ;;
                                remove)
                                    # For remove, only show tags from the selected entity
                                    COMPREPLY=($(compgen -W "$(_yatt_entity_tags "${words[4]}")" -- "$cur"))
                                    ;;
                            esac
                            ;;
                    esac
                    ;;
            esac
            ;;
    esac
}

complete -F _yatt_completion yatt
COMPLETION_EOF
}

# -------------------------------
# Help
# -------------------------------
help() {
    cat <<EOF
YATT - Yet Another Task Tracker

Usage:
  yatt <command> [subcommand] [options]

Commands:

Project management:
  project create <name> [description]                Create a new project
  project remove <name>                              Delete an existing project (asks for confirmation)
  project list                                       List projects and their submodules

Tag management:
  project tags add <project|module@project> <tag>    Add a tag (duplicates prevented)
  project tags remove <project|module@project> <tag> Remove a tag
  project tags list <project|module@project>         List tags of a project or submodule
  project tags by <tag>                              List all projects/submodules with the specified tag

Submodule management:
  submodule create <name>@<project> [description]    Create a submodule under a project
  submodule remove <name>@<project>                  Remove a submodule
  submodule list <project>                           List submodules of a project with details

Time tracking:
  track start <project|module@project>               Start tracking time
  track stop                                         Stop the active tracking session
  track status                                       Show the currently active session with elapsed time
  track list [project|module@project]                List all tracked sessions (optional filter)
  track report [project|module@project|tag:tagname] [YYYY-MM-DD]
                                                     Show report with optional filters:
                                                     - No args: today's report
                                                     - project/module: filter by project/module
                                                     - tag:tagname: filter by tag
                                                     - date: specific day's report
                                                     - Any combination of filter + date

Shell completion:
  completion                                         Generate shell completion script

Other:
  help                                               Show this help message

Examples:
  yatt project create myapp "Main backend project"
  yatt submodule create auth@myapp "Authentication service"
  yatt project tags add myapp backend
  yatt track start myapp
  yatt track stop
  yatt track report                          # Today's report
  yatt track report 2025-10-23               # Specific date
  yatt track report myapp                    # All myapp entries
  yatt track report myapp 2025-10-23         # myapp entries on specific date
  yatt track report tag:backend              # All entries with 'backend' tag
  yatt track report tag:backend 2025-10-23   # backend tag on specific date
EOF
}

# -------------------------------
# Project commands
# -------------------------------
project_create() {
    local name="$1"
    shift
    local desc="$*"
    local file="$PROJECTS_DIR/$name.json"

    if [[ -f "$file" ]]; then
        color_echo yellow "Project '$name' already exists."
        exit 1
    fi

    jq -n --arg n "$name" --arg d "$desc" '{name:$n, description:$d, tags:[], modules:[]}' > "$file"
    color_echo green "✅ Project '$name' created."
}

project_remove() {
    local name="$1"

    [[ -z "$name" ]] && { color_echo red "❌ Usage: project remove <name>"; exit 1; }

    local project_file="$PROJECTS_DIR/${name}.json"

    if [[ ! -f "$project_file" ]]; then
        color_echo red "❌ Project '$name' not found."
        exit 1
    fi

    # Confirm before deletion
    read -p "⚠️  Are you sure you want to delete project '$name'? (y/N): " confirm
    [[ "$confirm" =~ ^[Yy]$ ]] || { color_echo green "❌ Operation cancelled."; exit 0; }

    rm -f "$project_file"
    color_echo green "🗑️  Project '$name' removed."
}

project_list() {
    color_echo blue "📂 Projects:"
    for f in "$PROJECTS_DIR"/*.json; do
        [[ -f "$f" ]] || continue
        local project
        project=$(basename "$f" .json)
        color_echo purple "  - $project"
        local modules
        modules=$(jq -r '.modules[].name?' "$f")
        while IFS= read -r m; do
            [[ -z "$m" ]] && continue
            color_echo cyan "      * $m"
        done <<< "$modules"
    done
}

# -------------------------------
# Submodule commands
# -------------------------------
submodule_create() {
    local full="$1"
    shift
    local desc="$*"
    local module="${full%@*}"
    local parent="${full#*@}"
    local file="$PROJECTS_DIR/$parent.json"

    if [[ ! -f "$file" ]]; then
        color_echo red "Parent project '$parent' does not exist."
        exit 1
    fi

    if jq -e --arg m "$module" '.modules[] | select(.name==$m)' "$file" >/dev/null; then
        color_echo yellow "Submodule '$module@$parent' already exists."
        exit 1
    fi

    jq --arg m "$module" --arg d "$desc" '.modules += [{"name":$m, "description":$d, "tags":[]}]' "$file" \
       > "$file.tmp" && mv "$file.tmp" "$file"

    color_echo green "✅ Submodule '$module@$parent' created."
}

submodule_remove() {
    local full="$1"
    local module="${full%@*}"
    local parent="${full#*@}"
    local file="$PROJECTS_DIR/$parent.json"

    [[ -f "$file" ]] || { color_echo red "Parent project '$parent' does not exist."; exit 1; }

    jq --arg m "$module" '.modules |= map(select(.name != $m))' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
    color_echo green "✅ Submodule '$module@$parent' removed."
}

submodule_list() {
    local project="${1:-}"
    
    [[ -z "$project" ]] && { color_echo red "❌ Usage: submodule list <project>"; exit 1; }
    
    local file="$PROJECTS_DIR/$project.json"
    
    if [[ ! -f "$file" ]]; then
        color_echo red "❌ Project '$project' not found."
        exit 1
    fi
    
    local module_count
    module_count=$(jq '.modules | length' "$file")
    
    if [[ "$module_count" -eq 0 ]]; then
        color_echo red "📦 No submodules found in project '$project'."
        return 0
    fi
    
    color_echo green "📦 Submodules in project '$project':"
    echo ""
    
    local modules
    modules=$(jq -c '.modules[]' "$file")
    
    while IFS= read -r mod; do
        [[ -z "$mod" ]] && continue
        
        local mod_name mod_desc mod_tags
        mod_name=$(echo "$mod" | jq -r '.name')
        mod_desc=$(echo "$mod" | jq -r '.description // "No description"')
        mod_tags=$(echo "$mod" | jq -r '.tags[]?' | tr '\n' ', ' | sed 's/,$//')
        
        color_echo yellow "  🔹 $mod_name@$project"
        color_echo blue "     Description: $mod_desc"
        
        if [[ -n "$mod_tags" ]]; then
            color_echo purple "     Tags: $mod_tags"
        else
            color_echo purple "     Tags: (none)"
        fi
        echo ""
    done <<< "$modules"
}

# -------------------------------
# Tag commands
# -------------------------------
tags_add() {
    local key="${1:-}"
    local tag="${2:-}"
    
    [[ -z "$key" ]] && { color_echo red "❌ Usage: project tags add <project|module@project> <tag>"; exit 1; }
    [[ -z "$tag" ]] && { color_echo red "❌ Usage: project tags add <project|module@project> <tag>"; exit 1; }

    if [[ "$key" == *@* ]]; then
        # Submodule
        local module="${key%@*}"
        local parent="${key#*@}"
        local file="$PROJECTS_DIR/$parent.json"
        [[ -f "$file" ]] || { color_echo red "Parent project '$parent' does not exist"; exit 1; }

        local json
        json=$(json_read "$file")

        # Prevent duplicate tag
        if echo "$json" | jq -e --arg m "$module" --arg t "$tag" '.modules[] | select(.name==$m) | .tags | index($t)' >/dev/null; then
            color_echo yellow "✅ Tag '$tag' already present for submodule '$module@$parent'."
            return
        fi

        json=$(echo "$json" | jq --arg m "$module" --arg t "$tag" '
            .modules |= map(if .name==$m then .tags += [$t] else . end)
        ')
        json_write "$file" "$json"
        color_echo green "✅ Tag '$tag' added to submodule '$module@$parent'."

    else
        # Project
        local file="$PROJECTS_DIR/$key.json"
        [[ -f "$file" ]] || { color_echo red "Project '$key' does not exist"; exit 1; }

        local json
        json=$(json_read "$file")
        if echo "$json" | jq -e --arg t "$tag" '.tags | index($t)' >/dev/null; then
            color_echo yellow "✅ Tag '$tag' already present for project '$key'."
            return
        fi
        json=$(echo "$json" | jq --arg t "$tag" '.tags += [$t]')
        json_write "$file" "$json"
        color_echo green "✅ Tag '$tag' added to project '$key'."
    fi
}

tags_remove() {
    local key="${1:-}"
    local tag="${2:-}"
    
    [[ -z "$key" ]] && { color_echo red "❌ Usage: project tags remove <project|module@project> <tag>"; exit 1; }
    [[ -z "$tag" ]] && { color_echo red "❌ Usage: project tags remove <project|module@project> <tag>"; exit 1; }

    if [[ "$key" == *@* ]]; then
        # Submodule
        local module="${key%@*}"
        local parent="${key#*@}"
        local file="$PROJECTS_DIR/$parent.json"
        [[ -f "$file" ]] || { color_echo red "Parent project '$parent' does not exist"; exit 1; }

        jq --arg m "$module" --arg t "$tag" '
            .modules |= map(
                if .name==$m then .tags |= map(select(. != $t)) else . end
            )
        ' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
        color_echo green "✅ Tag '$tag' removed from submodule '$module@$parent'."

    else
        # Project
        local file="$PROJECTS_DIR/$key.json"
        [[ -f "$file" ]] || { color_echo red "Project '$key' does not exist"; exit 1; }

        jq --arg t "$tag" '.tags |= map(select(. != $t))' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
        color_echo green "✅ Tag '$tag' removed from project '$key'."
    fi
}

tags_list() {
    local key="${1:-}"
    
    [[ -z "$key" ]] && { color_echo red "❌ Usage: project tags list <project|module@project>"; exit 1; }

    if [[ "$key" == *@* ]]; then
        local module="${key%@*}"
        local parent="${key#*@}"
        local file="$PROJECTS_DIR/$parent.json"
        [[ -f "$file" ]] || { color_echo red "Parent project '$parent' does not exist"; exit 1; }
        json_read "$file" | jq -r --arg m "$module" '.modules[] | select(.name==$m) | .tags[]?'
    else
        local file="$PROJECTS_DIR/$key.json"
        [[ -f "$file" ]] || { color_echo red "Project '$key' does not exist"; exit 1; }
        json_read "$file" | jq -r '.tags[]?'
    fi
}

tags_by() {
    local tag="${1:-}"
    [[ -z "$tag" ]] && { color_echo red "❌ Usage: tags by <tag>"; return 1; }
    color_echo green "Projects/submodules with tag '$tag':"

    for f in "$PROJECTS_DIR"/*.json; do
        [[ -f "$f" ]] || continue
        local project=$(basename "$f" .json)
        local json
        json=$(json_read "$f")

        # If project has tag
        if echo "$json" | jq -e --arg t "$tag" '.tags | index($t)' >/dev/null; then
            color_echo yellow "  - $project"
        fi

        # Check modules
        local modules
        modules=$(echo "$json" | jq -c '.modules[]?')
        while IFS= read -r mod; do
            [[ -z "$mod" ]] && continue
            if echo "$mod" | jq -e --arg t "$tag" '.tags | index($t)' >/dev/null; then
                local mod_name
                mod_name=$(echo "$mod" | jq -r '.name')
                color_echo blue "      * $mod_name@$project"
            fi
        done <<< "$modules"
    done
}

# Helper function to get tags for a project or module
get_tags_for_entity() {
    local entity="$1"
    
    if [[ "$entity" == *@* ]]; then
        # Submodule
        local module="${entity%@*}"
        local parent="${entity#*@}"
        local file="$PROJECTS_DIR/$parent.json"
        [[ -f "$file" ]] || return
        jq -r --arg m "$module" '.modules[] | select(.name==$m) | .tags[]?' "$file" 2>/dev/null
    else
        # Project
        local file="$PROJECTS_DIR/$entity.json"
        [[ -f "$file" ]] || return
        jq -r '.tags[]?' "$file" 2>/dev/null
    fi
}

# -------------------------------
# Tracking
# -------------------------------
ensure_tracking_file() {
    if [[ ! -f "$TRACK_FILE" ]]; then
        echo '{"active_session": null, "sessions": []}' > "$TRACK_FILE"
    fi
}

track_start() {
    local name="${1:-}"
    [[ -z "$name" ]] && { color_echo red "❌ Usage: yatt track start <project|module@project>"; return 1; }

    ensure_tracking_file

    # Check if active session exists
    local active
    active=$(jq -r '.active_session' "$TRACK_FILE" 2>/dev/null)
    
    if [[ "$active" != "null" ]]; then
        color_echo red "❌ A session is already active. Stop it first with 'yatt track stop'."
        return 1
    fi

    # Check if project/module exists
    local project_file
    if [[ "$name" == *@* ]]; then
        local parent="${name#*@}"
        project_file="$PROJECTS_DIR/${parent}.json"
        [[ ! -f "$project_file" ]] && { color_echo red "❌ Project '$parent' not found."; return 1; }
    else
        project_file="$PROJECTS_DIR/${name}.json"
        [[ ! -f "$project_file" ]] && { color_echo red "❌ Project '$name' not found."; return 1; }
    fi

    local start_time
    start_time=$(date -Iseconds)

    # Get tags for the entity
    local tags_array
    tags_array=$(get_tags_for_entity "$name" | jq -R -s -c 'split("\n") | map(select(length > 0))')
    [[ -z "$tags_array" || "$tags_array" == "[]" ]] && tags_array="[]"

    # Update tracking file with active session using jq
    jq --arg name "$name" --arg start "$start_time" --argjson tags "$tags_array" \
        '.active_session = {name: $name, start: $start, tags: $tags}' \
        "$TRACK_FILE" > "$TRACK_FILE.tmp" && mv "$TRACK_FILE.tmp" "$TRACK_FILE"

    color_echo green "▶️  Tracking started for '$name' at $start_time"
}

track_stop() {
    ensure_tracking_file

    # Read the active session
    local active
    active=$(jq -r '.active_session' "$TRACK_FILE" 2>/dev/null)

    # If no active session
    if [[ "$active" == "null" ]]; then
        color_echo red "❌ No active session to stop."
        return 1
    fi

    # Extract session details
    local name start_time tags_json end_time
    name=$(jq -r '.active_session.name' "$TRACK_FILE")
    start_time=$(jq -r '.active_session.start' "$TRACK_FILE")
    tags_json=$(jq -c '.active_session.tags' "$TRACK_FILE")
    end_time=$(date -Iseconds)

    # Calculate elapsed seconds
    local start_epoch now_epoch elapsed
    start_epoch=$(date -d "$start_time" +%s)
    now_epoch=$(date +%s)
    elapsed=$(( now_epoch - start_epoch ))

    # Extract date for the session
    local session_date
    session_date=$(date -d "$start_time" +%F)

    # Create new session entry and update tracking file
    jq --arg name "$name" \
       --arg start "$start_time" \
       --arg end "$end_time" \
       --arg date "$session_date" \
       --argjson elapsed "$elapsed" \
       --argjson tags "$tags_json" \
        '.sessions += [{name: $name, start: $start, end: $end, date: $date, duration_seconds: $elapsed, tags: $tags}] | .active_session = null' \
        "$TRACK_FILE" > "$TRACK_FILE.tmp" && mv "$TRACK_FILE.tmp" "$TRACK_FILE"

    color_echo green "✅ Stopped tracking '$name'. Duration: $(format_seconds $elapsed)"
}

track_status() {
    ensure_tracking_file

    # Extract the 'active_session' object
    local active
    active=$(jq -r '.active_session' "$TRACK_FILE" 2>/dev/null)

    # If no active session
    if [[ "$active" == "null" ]]; then
        color_echo blue "🟢 No active tracking session."
        return 0
    fi

    # Extract name and start timestamp
    local name start_time
    name=$(jq -r '.active_session.name' "$TRACK_FILE")
    start_time=$(jq -r '.active_session.start' "$TRACK_FILE")

    # Convert start_time to epoch
    local start_epoch now_epoch elapsed
    start_epoch=$(date -d "$start_time" +%s 2>/dev/null) || {
        color_echo red "❌ Invalid start timestamp: $start_time"
        return 1
    }
    now_epoch=$(date +%s)
    elapsed=$(( now_epoch - start_epoch ))

    local h=$((elapsed / 3600))
    local m=$(( (elapsed % 3600) / 60 ))
    local s=$((elapsed % 60))

    color_echo blue "⏳ Tracking: $name"
    color_echo green "   Started:  $start_time"
    color_echo yellow "   Elapsed:  ${h}h ${m}m ${s}s"
}

track_list() {
    ensure_tracking_file
    
    local filter="${1:-}"
    local sessions
    sessions=$(jq -c '.sessions[]' "$TRACK_FILE" 2>/dev/null)
    
    if [[ -z "$sessions" ]]; then
        color_echo yellow "No tracking sessions found."
        return 0
    fi

    color_echo blue "📋 Tracking Sessions:"
    echo ""

    while IFS= read -r session; do
        [[ -z "$session" ]] && continue
        
        local name start end duration date
        name=$(echo "$session" | jq -r '.name')
        
        # Apply filter if provided
        if [[ -n "$filter" && "$name" != "$filter" ]]; then
            continue
        fi
        
        start=$(echo "$session" | jq -r '.start')
        end=$(echo "$session" | jq -r '.end')
        duration=$(echo "$session" | jq -r '.duration_seconds')
        date=$(echo "$session" | jq -r '.date')

        color_echo cyan "  📌 $name ($date)"
        color_echo green "     Start: $start"
        color_echo yellow "     End: $end"
        color_echo purple "     Duration: $(format_seconds $duration)"
        echo ""
    done <<< "$sessions"
}

track_report() {
    ensure_tracking_file
    
    local arg1="${1:-}"
    local arg2="${2:-}"
    local filter_entity=""
    local filter_tag=""
    local date_filter=""
    
    # Parse arguments
    # Check if arg1 is a date (YYYY-MM-DD format)
    if [[ "$arg1" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
        date_filter="$arg1"
    elif [[ "$arg1" == tag:* ]]; then
        filter_tag="${arg1#tag:}"
        if [[ "$arg2" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
            date_filter="$arg2"
        fi
    elif [[ -n "$arg1" ]]; then
        filter_entity="$arg1"
        if [[ "$arg2" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
            date_filter="$arg2"
        fi
    fi
    
    # Default to today if no date specified
    [[ -z "$date_filter" ]] && date_filter=$(date +%F)
    
    local sessions
    sessions=$(jq -c '.sessions[]' "$TRACK_FILE" 2>/dev/null)
    
    if [[ -z "$sessions" ]]; then
        color_echo yellow "No tracking sessions found."
        return 0
    fi

    # Build report header
    local header="📅 Report for $date_filter"
    if [[ -n "$filter_entity" ]]; then
        header="$header (filtered by: $filter_entity)"
    elif [[ -n "$filter_tag" ]]; then
        header="$header (filtered by tag: $filter_tag)"
    fi
    color_echo blue "$header"
    echo ""

    declare -A totals
    local found_any=false

    while IFS= read -r session; do
        [[ -z "$session" ]] && continue
        
        local name start date duration tags_json
        name=$(echo "$session" | jq -r '.name')
        date=$(echo "$session" | jq -r '.date')
        duration=$(echo "$session" | jq -r '.duration_seconds')
        tags_json=$(echo "$session" | jq -c '.tags')
        
        # Filter by date
        [[ "$date" != "$date_filter" ]] && continue
        
        # Filter by entity if specified
        if [[ -n "$filter_entity" && "$name" != "$filter_entity" ]]; then
            continue
        fi
        
        # Filter by tag if specified
        if [[ -n "$filter_tag" ]]; then
            local has_tag=false
            while IFS= read -r tag; do
                if [[ "$tag" == "$filter_tag" ]]; then
                    has_tag=true
                    break
                fi
            done < <(echo "$tags_json" | jq -r '.[]?')
            [[ "$has_tag" == false ]] && continue
        fi
        
        found_any=true
        totals["$name"]=$(( ${totals["$name"]:-0} + duration ))
    done <<< "$sessions"

    if [[ "$found_any" == false ]]; then
        color_echo yellow "No entries found for the specified criteria."
        return 0
    fi

    # Display totals
    local total_sec=0
    for name in "${!totals[@]}"; do
        local d=${totals[$name]}
        total_sec=$((total_sec + d))
        color_echo green "  • $name: $(format_seconds $d)"
    done
    
    echo ""
    color_echo cyan "━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    color_echo cyan "Total time: $(format_seconds $total_sec)"
}

# -------------------------------
# Main
# -------------------------------
main() {
    [[ $# -eq 0 ]] && { help; exit 0; }

    local cmd="$1"; shift || true
    case "$cmd" in
        help|-h|--help)
            help
            ;;

        completion)
            generate_completion
            ;;

        project)
            local sub="$1"; shift || true
            case "$sub" in
                create)
                    local target="$1"
                    shift
                    project_create "$target" "$@"
                    ;;
                remove)
                    project_remove "$@"
                    ;;
                list)
                    project_list
                    ;;
                tags)
                    local tagcmd="$1"; shift || true
                    case "$tagcmd" in
                        add)
                            tags_add "$@"
                            ;;
                        remove)
                            tags_remove "$@"
                            ;;
                        list)
                            tags_list "$@"
                            ;;
                        by)
                            tags_by "$@"
                            ;;
                        *)
                            color_echo red "❌ Unknown tag command: $tagcmd"
                            help
                            ;;
                    esac
                    ;;
                *)
                    color_echo red "❌ Unknown project subcommand: $sub"
                    help
                    ;;
            esac
            ;;

        track)
            local sub="$1"; shift || true
            case "$sub" in
                start) track_start "$@" ;;
                stop) track_stop ;;
                status) track_status ;;
                list) track_list "$@" ;;
                report) track_report "$@" ;;
                *) help ;;
            esac
            ;;

        submodule)
            local sub="$1"; shift || true
            case "$sub" in
                create)
                    local target="$1"
                    shift
                    submodule_create "$target" "$@"
                    ;;
                remove)
                    submodule_remove "$@"
                    ;;
                list)
                    submodule_list "$@"
                    ;;
                *)
                    color_echo red "❌ Unknown submodule subcommand: $sub"
                    help
                    ;;
            esac
            ;;
        
        *)
            color_echo red "❌ Unknown command: $cmd"
            help
            ;;
    esac
}

main "$@"
