#!/usr/bin/env bash

set -euo pipefail

YATT_DIR="$HOME/.yatt"
PROJECTS_DIR="$YATT_DIR/projects"
TRACK_FILE="$HOME/.yatt/tracking.json"

mkdir -p "$PROJECTS_DIR"

# -------------------------------
# Utilities
# -------------------------------
json_read() { jq '.' "$1"; }
json_write() { echo "$2" > "$1"; }

color_echo() {
  local color_name="$1"
  local text="$2"

  # Map color names to ANSI color codes
  case "$color_name" in
    black)   color_code="30" ;;
    red)     color_code="31" ;;
    green)   color_code="32" ;;
    yellow)  color_code="33" ;;
    blue)    color_code="34" ;;
    purple|magenta) color_code="35" ;;
    cyan)    color_code="36" ;;
    white)   color_code="37" ;;
    *) echo "Unknown color: $color_name" >&2; return 1 ;;
  esac

  # Print text in color
  echo -e "\033[${color_code}m${text}\033[0m"
}

format_seconds() {
    local T=$1
    local H M S
    H=$((T/3600))
    M=$(( (T%3600)/60 ))
    S=$((T%60))
    printf "%02d:%02d:%02d\n" $H $M $S
}

# -------------------------------
# Help
# -------------------------------
help() {
    cat <<EOF
YATT - Yet Another Task Tracker

Usage:
  yatt <command> [subcommand] [options]

Commands:

Project management:
  project create <name> [description]                Create a new project
  project remove <name>                              Delete an existing project (asks for confirmation)
  project list                                       List projects and their submodules

Tag management:
  project tags add <project|module@project> <tag>    Add a tag (duplicates prevented)
  project tags remove <project|module@project> <tag> Remove a tag
  project tags list <project|module@project>         List tags of a project or submodule
  project tags by <tag>                              List all projects/submodules with the specified tag

Submodule management:
  submodule create <name>@<project> [description]    Create a submodule under a project
  submodule remove <name>@<project>                  Remove a submodule
  submodule list <project>                           List submodules of a project with details

Time tracking:
  track start <project|module@project>               Start tracking time
  track stop                                         Stop the active tracking session
  track status                                       Show the currently active session with elapsed time
  track list [project|module@project]                List all tracked sessions (optional filter by project/module)
  track report [YYYY-MM-DD]                          Show daily report (default: today) with durations and total time

Other:
  help                                               Show this help message

Examples:
  yatt project create myapp "Main backend project"
  yatt submodule create auth@myapp "Authentication service"
  yatt submodule list myapp
  yatt project tags add myapp backend
  yatt project tags by backend
  yatt project remove myapp
  yatt track start make-coffee
  yatt track stop
  yatt track report 2025-10-23
EOF
}

# -------------------------------
# Project commands
# -------------------------------
project_create() {
    local name="$1"
    shift
    local desc="$*"
    local file="$PROJECTS_DIR/$name.json"

    if [[ -f "$file" ]]; then
        #echo "Project '$name' already exists."
        color_echo yellow "Project '$name' already exists."
        exit 1
    fi

    jq -n --arg n "$name" --arg d "$desc" '{name:$n, description:$d, tags:[], modules:[]}' > "$file"
    color_echo green "‚úÖ Project '$name' created."
}

project_remove() {
    local name="$1"

    [[ -z "$name" ]] && { color_echo red "‚ùå Usage: project remove <name>"; exit 1; }

    local project_file="$PROJECTS_DIR/${name}.json"

    if [[ ! -f "$project_file" ]]; then
        color_echo red "‚ùå Project '$name' not found."
        exit 1
    fi

    # Confirm before deletion
    read -p "‚ö†Ô∏è  Are you sure you want to delete project '$name'? (y/N): " confirm
    [[ "$confirm" =~ ^[Yy]$ ]] || { color_echo green "‚ùå Operation cancelled."; exit 0; }

    rm -f "$project_file"
    color_echo green "üóëÔ∏è  Project '$name' removed."
}

project_list() {
    color_echo blue "üìÇ Projects:"
    for f in "$PROJECTS_DIR"/*.json; do
        [[ -f "$f" ]] || continue
        local project
        project=$(basename "$f" .json)
        color_echo purple "  - $project"
        local modules
        modules=$(jq -r '.modules[].name?' "$f")
        while IFS= read -r m; do
            [[ -z "$m" ]] && continue
            color_echo cyan "      * $m"
        done <<< "$modules"
    done
}

# -------------------------------
# Submodule commands
# -------------------------------
submodule_create() {
    local full="$1"
    shift
    local desc="$*"
    local module="${full%@*}"
    local parent="${full#*@}"
    local file="$PROJECTS_DIR/$parent.json"

    if [[ ! -f "$file" ]]; then
        color_echo red "Parent project '$parent' does not exist."
        exit 1
    fi

    if jq -e --arg m "$module" '.modules[] | select(.name==$m)' "$file" >/dev/null; then
        color_echo yellow "Submodule '$module@$parent' already exists."
        exit 1
    fi

    jq --arg m "$module" --arg d "$desc" '.modules += [{"name":$m, "description":$d, "tags":[]}]' "$file" \
       > "$file.tmp" && mv "$file.tmp" "$file"

    color_echo green "‚úÖ Submodule '$module@$parent' created."
}

submodule_remove() {
    local full="$1"
    local module="${full%@*}"
    local parent="${full#*@}"
    local file="$PROJECTS_DIR/$parent.json"

    [[ -f "$file" ]] || { echo "Parent project '$parent' does not exist."; exit 1; }

    jq --arg m "$module" '.modules |= map(select(.name != $m))' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
    color_echo green "‚úÖ Submodule '$module@$parent' removed."
}

submodule_list() {
    local project="${1:-}"
    
    [[ -z "$project" ]] && { color_echo red "‚ùå Usage: submodule list <project>"; exit 1; }
    
    local file="$PROJECTS_DIR/$project.json"
    
    if [[ ! -f "$file" ]]; then
        colro_echo red "‚ùå Project '$project' not found."
        exit 1
    fi
    
    local module_count
    module_count=$(jq '.modules | length' "$file")
    
    if [[ "$module_count" -eq 0 ]]; then
        color_echo red "üì¶ No submodules found in project '$project'."
        return 0
    fi
    
    color_echo green "üì¶ Submodules in project '$project':"
    echo ""
    
    local modules
    modules=$(jq -c '.modules[]' "$file")
    
    while IFS= read -r mod; do
        [[ -z "$mod" ]] && continue
        
        local mod_name mod_desc mod_tags
        mod_name=$(echo "$mod" | jq -r '.name')
        mod_desc=$(echo "$mod" | jq -r '.description // "No description"')
        mod_tags=$(echo "$mod" | jq -r '.tags[]?' | tr '\n' ', ' | sed 's/,$//')
        
        color_echo yellow "  üîπ $mod_name@$project"
        color_echo blue "     Description: $mod_desc"
        
        if [[ -n "$mod_tags" ]]; then
            color_echo purple "     Tags: $mod_tags"
        else
            color_echo purple "     Tags: (none)"
        fi
        echo ""
    done <<< "$modules"
}

# -------------------------------
# Tag commands
# -------------------------------
tags_add() {
    local key="${1:-}"
    local tag="${2:-}"
    
    [[ -z "$key" ]] && { color_echo red "‚ùå Usage: project tags add <project|module@project> <tag>"; exit 1; }
    [[ -z "$tag" ]] && { color_echo red "‚ùå Usage: project tags add <project|module@project> <tag>"; exit 1; }

    if [[ "$key" == *@* ]]; then
        # Submodule
        local module="${key%@*}"
        local parent="${key#*@}"
        local file="$PROJECTS_DIR/$parent.json"
        [[ -f "$file" ]] || { color_echo red "Parent project '$parent' does not exist"; exit 1; }

        local json
        json=$(json_read "$file")

        # Prevent duplicate tag
        if echo "$json" | jq -e --arg m "$module" --arg t "$tag" '.modules[] | select(.name==$m) | .tags | index($t)' >/dev/null; then
            color_echo yellow "‚úÖ Tag '$tag' already present for submodule '$module@$parent'."
            return
        fi

        json=$(echo "$json" | jq --arg m "$module" --arg t "$tag" '
            .modules |= map(if .name==$m then .tags += [$t] else . end)
        ')
        json_write "$file" "$json"
        color_echo green "‚úÖ Tag '$tag' added to submodule '$module@$parent'."

    else
        # Project
        local file="$PROJECTS_DIR/$key.json"
        [[ -f "$file" ]] || { color_echo red "Project '$key' does not exist"; exit 1; }

        local json
        json=$(json_read "$file")
        if echo "$json" | jq -e --arg t "$tag" '.tags | index($t)' >/dev/null; then
            color_echo yellow "‚úÖ Tag '$tag' already present for project '$key'."
            return
        fi
        json=$(echo "$json" | jq --arg t "$tag" '.tags += [$t]')
        json_write "$file" "$json"
        color_echo green "‚úÖ Tag '$tag' added to project '$key'."
    fi
}
tags_remove() {
    local key="${1:-}"
    local tag="${2:-}"
    
    [[ -z "$key" ]] && { color_echo red "‚ùå Usage: project tags remove <project|module@project> <tag>"; exit 1; }
    [[ -z "$tag" ]] && { color_echo red "‚ùå Usage: project tags remove <project|module@project> <tag>"; exit 1; }

    if [[ "$key" == *@* ]]; then
        # Submodule
        local module="${key%@*}"
        local parent="${key#*@}"
        local file="$PROJECTS_DIR/$parent.json"
        [[ -f "$file" ]] || { color_echo red "Parent project '$parent' does not exist"; exit 1; }

        jq --arg m "$module" --arg t "$tag" '
            .modules |= map(
                if .name==$m then .tags |= map(select(. != $t)) else . end
            )
        ' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
        color_echo green "‚úÖ Tag '$tag' removed from submodule '$module@$parent'."

    else
        # Project
        local file="$PROJECTS_DIR/$key.json"
        [[ -f "$file" ]] || { color_echo red "Project '$key' does not exist"; exit 1; }

        jq --arg t "$tag" '.tags |= map(select(. != $t))' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
        color_echo green "‚úÖ Tag '$tag' removed from project '$key'."
    fi
}

tags_list() {
    local key="${1:-}"
    
    [[ -z "$key" ]] && { color_echo red "‚ùå Usage: project tags list <project|module@project>"; exit 1; }

    if [[ "$key" == *@* ]]; then
        local module="${key%@*}"
        local parent="${key#*@}"
        local file="$PROJECTS_DIR/$parent.json"
        [[ -f "$file" ]] || { color_echo red "Parent project '$parent' does not exist"; exit 1; }
        json_read "$file" | jq -r --arg m "$module" '.modules[] | select(.name==$m) | .tags[]?'
    else
        local file="$PROJECTS_DIR/$key.json"
        [[ -f "$file" ]] || { color_echo red "Project '$key' does not exist"; exit 1; }
        json_read "$file" | jq -r '.tags[]?'
    fi
}

tags_by() {
    local tag="${1:-}"
    [[ -z "$tag" ]] && { color_echo red "‚ùå Usage: tags by <tag>"; return 1; }
    color_echo green "Projects/submodules with tag '$tag':"

    for f in "$PROJECTS_DIR"/*.json; do
        [[ -f "$f" ]] || continue
        local project=$(basename "$f" .json)
        local json
        json=$(json_read "$f")

        # If project has tag
        if echo "$json" | jq -e --arg t "$tag" '.tags | index($t)' >/dev/null; then
            color_echo yellow "  - $project"
        fi

        # Check modules
        local modules
        modules=$(echo "$json" | jq -c '.modules[]?')
        while IFS= read -r mod; do
            [[ -z "$mod" ]] && continue
            if echo "$mod" | jq -e --arg t "$tag" '.tags | index($t)' >/dev/null; then
                local mod_name
                mod_name=$(echo "$mod" | jq -r '.name')
                color_echo blue "      * $mod_name@$project"
            fi
        done <<< "$modules"
    done
}

# -------------------------------
# Tracing
# -------------------------------
ensure_tracking_file() {
    [[ -f "$TRACK_FILE" ]] || color_echo red '{"active": null, "logs": []}' > "$TRACK_FILE"
}

track_start() {
    local name="$1"
    [[ -z "$name" ]] && { color_echo red "‚ùå Usage: yatt track start <project|module@project>"; return 1; }

    ensure_tracking_file

    # Check if active session exists
    if grep -q '"active": {' "$TRACK_FILE"; then
        color_echo red "‚ùå A session is already active. Stop it first with 'yatt track stop'."
        return 1
    fi

    # Check if project exists
    local project_file
    if [[ "$name" == *@* ]]; then
        local parent="${name#*@}"
        project_file="$PROJECTS_DIR/${parent}.json"
        [[ ! -f "$project_file" ]] && { color_echo red "‚ùå Project '$parent' not found."; return 1; }
    else
        project_file="$PROJECTS_DIR/${name}.json"
        [[ ! -f "$project_file" ]] && { color_echo red "‚ùå Project '$name' not found."; return 1; }
    fi

    local start_time
    start_time=$(date -Iseconds)

    # Write active session (don't overwrite logs)
    awk -v n="$name" -v t="$start_time" '
        BEGIN { active_written=0 }
        {
            if ($0 ~ /"active": null/) {
                print "  \"active\": {\"name\": \"" n "\", \"start\": \"" t "\"},"
                active_written=1
            } else {
                print
            }
        }
        END {
            if (!active_written) print "  \"active\": {\"name\": \"" n "\", \"start\": \"" t "\"},"
        }
    ' "$TRACK_FILE" > "$TRACK_FILE.tmp" && mv "$TRACK_FILE.tmp" "$TRACK_FILE"

    color_echo green "‚ñ∂Ô∏è Tracking started for '$name' at $start_time"
}

track_stop() {
    ensure_tracking_file

    # Read the active session
    local active_line
    active_line=$(grep -oP '"active": *\{[^}]*\}' "$TRACK_FILE")

    # If no active session
    if [[ -z "$active_line" || "$active_line" == *"null"* ]]; then
        color_echo red "‚ùå No active session to stop."
        return 1
    fi

    # Extract name and start timestamp
    local name start_time end_time
    name=$(echo "$active_line" | grep -oP '"name": *"\K[^"]+')
    start_time=$(echo "$active_line" | grep -oP '"start": *"\K[^"]+')
    end_time=$(date -Iseconds)

    # Calculate elapsed seconds
    local start_epoch now_epoch elapsed
    start_epoch=$(date -d "$start_time" +%s)
    now_epoch=$(date +%s)
    elapsed=$(( now_epoch - start_epoch ))

    # Append to logs
    # Read existing logs
    local logs
    logs=$(jq '.logs' "$TRACK_FILE")

    # Create new log entry
    local new_log
    new_log=$(jq -n --arg name "$name" --arg start "$start_time" --arg end "$end_time" --arg elapsed "$elapsed" \
        '{name: $name, start: $start, end: $end, elapsed_seconds: ($elapsed|tonumber)}')

    # Update tracking.json: append log and clear active
    jq --argjson newlog "$new_log" '.logs += [$newlog] | .active = null' "$TRACK_FILE" > "$TRACK_FILE.tmp" && mv "$TRACK_FILE.tmp" "$TRACK_FILE"

    color_echo green "‚úÖ Stopped tracking '$name'. Duration: $elapsed seconds."
}

track_status() {
    ensure_tracking_file

    # Extract the 'active' object
    local active_line
    active_line=$(grep -oP '"active": *\{[^}]*\}' "$TRACK_FILE")

    # If no active session
    if [[ -z "$active_line" || "$active_line" == *"null"* ]]; then
        color_echo blue "üü¢ No active tracking session."
        return 0
    fi

    # Extract name and start timestamp
    local name start_time
    name=$(echo "$active_line" | grep -oP '"name": *"\K[^"]+')
    start_time=$(echo "$active_line" | grep -oP '"start": *"\K[^"]+')

    # Convert start_time to epoch
    local start_epoch now_epoch elapsed
    start_epoch=$(date -d "$start_time" +%s 2>/dev/null) || {
        color_echo red "‚ùå Invalid start timestamp: $start_time"
        return 1
    }
    now_epoch=$(date +%s)
    elapsed=$(( now_epoch - start_epoch ))

    local h=$((elapsed / 3600))
    local m=$(( (elapsed % 3600) / 60 ))
    local s=$((elapsed % 60))

    color_echo blue "‚è≥ Tracking: $name"
    color_echo green "   Started:  $start_time"
    color_echo yellow "   Elapsed:  ${h}h ${m}m ${s}s"
}

track_list() {
    local project="${1:-}"
    local logs
    logs=$(jq -c '.logs[]' "$TRACK_FILE")

    for entry in $logs; do
        local name start end duration
        name=$(echo "$entry" | jq -r '.name')
        [[ -n "$project" && "$name" != "$project" ]] && continue
        start=$(echo "$entry" | jq -r '.start')
        end=$(echo "$entry" | jq -r '.end // empty')

        if [[ -n "$end" ]]; then
            duration=$(( $(date -d "$end" +%s) - $(date -d "$start" +%s) ))
        else
            duration="active"
        fi

        color_echo blue "Project/Submodule: $name"
        color_echo green "  Start: $start"
        color_echo yellow "  End: ${end:-active}"
        if [[ "$duration" != "active" ]]; then
            printf "  Duration: %02d:%02d:%02d\n" $((duration/3600)) $(((duration%3600)/60)) $((duration%60))
        else
            echo "  Duration: active"
        fi
        echo
    done
}

track_report() {
    local date_filter="${1:-$(date +%F)}"
    local logs
    logs=$(jq -c '.logs[]' "$TRACK_FILE")
    declare -A totals

    echo "üìÖ Report for $date_filter"

    for entry in $logs; do
        local name start end duration day
        name=$(echo "$entry" | jq -r '.name')
        start=$(echo "$entry" | jq -r '.start')
        end=$(echo "$entry" | jq -r '.end // empty')
        day=$(date -d "$start" +%F)

        [[ "$day" != "$date_filter" ]] && continue
        if [[ -n "$end" ]]; then
            duration=$(( $(date -d "$end" +%s) - $(date -d "$start" +%s) ))
        else
            duration=0
        fi
        totals["$name"]=$(( ${totals["$name"]:-0} + duration ))
    done

    local total_sec=0
    for name in "${!totals[@]}"; do
        local d=${totals[$name]}
        total_sec=$((total_sec + d))
        printf "  - %s: %02d:%02d:%02d\n" "$name" $((d/3600)) $(((d%3600)/60)) $((d%60))
    done

    printf "Total time: %02d:%02d:%02d\n" $((total_sec/3600)) $(((total_sec%3600)/60)) $((total_sec%60))
}

# -------------------------------
# Main
# -------------------------------
main() {
    [[ $# -eq 0 ]] && { help; exit 0; }

    local cmd="$1"; shift || true
    case "$cmd" in
        help|-h|--help)
            help
            ;;

        project)
            local sub="$1"; shift || true
            case "$sub" in
                create)
                    local target="$1"
                    shift
                    #project_create "$@"
                    project_create "$target" "$@"
                    ;;
                remove)
                    project_remove "$@"
                    ;;
                list)
                    project_list
                    ;;
                tags)
                    local tagcmd="$1"; shift || true
                    case "$tagcmd" in
                        add)
                            tags_add "$@"
                            ;;
                        remove)
                            tags_remove "$@"
                            ;;
                        list)
                            tags_list "$@"
                            ;;
                        by)
                            tags_by "$@"
                            ;;
                        search)
                            tags_search_all "$@"
                            ;;
                        *)
                            color_echo red "‚ùå Unknown tag command: $tagcmd"
                            help
                            ;;
                    esac
                    ;;
                *)
                    color_echo red "‚ùå Unknown project subcommand: $sub"
                    help
                    ;;
            esac
            ;;

        track)
            local sub="$1"; shift || true
            case "$sub" in
                start) track_start "$@" ;;
                stop) track_stop ;;
                status) track_status ;;
                list) track_list "$@" ;;
                report) track_report "$@" ;;
                *) help ;;
            esac
            ;;

        submodule)
            local sub="$1"; shift || true
            case "$sub" in
                create)
                    local target="$1"
                    shift
                    submodule_create "$target" "$@"
                    ;;
                remove)
                    submodule_remove "$@"
                    ;;
                list)
                    submodule_list "$@"
                    ;;
                *)
                    color_echo red "‚ùå Unknown submodule subcommand: $sub"
                    help
                    ;;
            esac
            ;;
        
        *)
            color_echo red "‚ùå Unknown command: $cmd"
            help
            ;;
    esac
}

main "$@"