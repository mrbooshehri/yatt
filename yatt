#!/usr/bin/env bash

set -euo pipefail

YATT_DIR="$HOME/.yatt"
PROJECTS_DIR="$YATT_DIR/projects"
TRACK_FILE="$HOME/.yatt/tracking.json"

mkdir -p "$YATT_DIR"
mkdir -p "$PROJECTS_DIR"

# -------------------------------
# Utilities
# -------------------------------
json_read() { jq '.' "$1"; }
json_write() { echo "$2" > "$1"; }

color_echo() {
  local color_name="$1"
  local text="$2"

  # Map color names to ANSI color codes
  case "$color_name" in
    black)   color_code="30" ;;
    red)     color_code="31" ;;
    green)   color_code="32" ;;
    yellow)  color_code="33" ;;
    blue)    color_code="34" ;;
    purple|magenta) color_code="35" ;;
    cyan)    color_code="36" ;;
    white)   color_code="37" ;;
    *) echo "Unknown color: $color_name" >&2; return 1 ;;
  esac

  # Print text in color
  echo -e "\033[${color_code}m${text}\033[0m"
}

format_seconds() {
    local T=$1
    local H M S
    H=$((T/3600))
    M=$(( (T%3600)/60 ))
    S=$((T%60))
    printf "%02d:%02d:%02d" $H $M $S
}

# -------------------------------
# Bash Completion Generator
# -------------------------------
generate_completion() {
    cat <<'COMPLETION_EOF'
# Bash completion for yatt
_yatt_completion() {
    local cur prev words cword
    _init_completion || return

    local YATT_DIR="$HOME/.yatt"
    local PROJECTS_DIR="$YATT_DIR/projects"

    # Get list of projects
    _yatt_projects() {
        if [[ -d "$PROJECTS_DIR" ]]; then
            for f in "$PROJECTS_DIR"/*.json; do
                [[ -f "$f" ]] && basename "$f" .json
            done
        fi
    }

    # Get list of submodules for a project
    _yatt_submodules() {
        local project="$1"
        if [[ -f "$PROJECTS_DIR/$project.json" ]]; then
            jq -r '.modules[].name' "$PROJECTS_DIR/$project.json" 2>/dev/null | while read -r mod; do
                echo "$mod@$project"
            done
        fi
    }

    # Get all projects and submodules
    _yatt_all_entities() {
        _yatt_projects
        for proj in $(_yatt_projects); do
            _yatt_submodules "$proj"
        done
    }

    # Get tasks for a project or submodule
    _yatt_tasks() {
        local target="$1"
        if [[ "$target" == *@* ]]; then
            local module="${target%@*}"
            local project="${target#*@}"
            local file="$PROJECTS_DIR/$project.json"
            [[ -f "$file" ]] && jq -r --arg m "$module" '.modules[] | select(.name==$m) | .tasks[].title' "$file" 2>/dev/null
        else
            local file="$PROJECTS_DIR/$target.json"
            [[ -f "$file" ]] && jq -r '.tasks[].title' "$file" 2>/dev/null
        fi
    }

    # Get all tags
    _yatt_all_tags() {
        if [[ -d "$PROJECTS_DIR" ]]; then
            for f in "$PROJECTS_DIR"/*.json; do
                [[ -f "$f" ]] && jq -r '.tags[]?, .modules[].tags[]?, .tasks[].tags[]?, .modules[].tasks[].tags[]?' "$f" 2>/dev/null
            done | sort -u
        fi
    }

    # Get tags for a specific entity
    _yatt_entity_tags() {
        local entity="$1"
        if [[ "$entity" == *@* ]]; then
            # Submodule
            local module="${entity%@*}"
            local parent="${entity#*@}"
            local file="$PROJECTS_DIR/$parent.json"
            [[ -f "$file" ]] && jq -r --arg m "$module" '.modules[] | select(.name==$m) | .tags[]?' "$file" 2>/dev/null
        else
            # Project
            local file="$PROJECTS_DIR/$entity.json"
            [[ -f "$file" ]] && jq -r '.tags[]?' "$file" 2>/dev/null
        fi
    }

    # Get list of backup files
    _yatt_backups() {
        local BACKUP_DIR="$YATT_DIR/backups"
        if [[ -d "$BACKUP_DIR" ]]; then
            for f in "$BACKUP_DIR"/*.tar.gz; do
                [[ -f "$f" ]] && basename "$f"
            done
        fi
    }

    case $cword in
        1)
            COMPREPLY=($(compgen -W "project submodule track task backup help completion" -- "$cur"))
            ;;
        2)
            case ${words[1]} in
                project)
                    COMPREPLY=($(compgen -W "create remove list edit tags" -- "$cur"))
                    ;;
                submodule)
                    COMPREPLY=($(compgen -W "create remove list edit tags" -- "$cur"))
                    ;;
                track)
                    COMPREPLY=($(compgen -W "start stop status list report" -- "$cur"))
                    ;;
                task)
                    COMPREPLY=($(compgen -W "create list update" -- "$cur"))
                    ;;
                backup)
                    COMPREPLY=($(compgen -W "create list restore" -- "$cur"))
                    ;;
            esac
            ;;
        3)
            case ${words[1]} in
                project)
                    case ${words[2]} in
                        remove)
                            COMPREPLY=($(compgen -W "$(_yatt_projects)" -- "$cur"))
                            ;;
                        edit)
                            COMPREPLY=($(compgen -W "$(_yatt_projects)" -- "$cur"))
                            ;;
                        tags)
                            COMPREPLY=($(compgen -W "add remove list by" -- "$cur"))
                            ;;
                    esac
                    ;;
                submodule)
                    case ${words[2]} in
                        remove)
                            COMPREPLY=($(compgen -W "$(_yatt_all_entities | grep @)" -- "$cur"))
                            ;;
                        edit)
                            COMPREPLY=($(compgen -W "$(_yatt_all_entities | grep @)" -- "$cur"))
                            ;;
                        list)
                            COMPREPLY=($(compgen -W "$(_yatt_projects)" -- "$cur"))
                            ;;
                        tags)
                            COMPREPLY=($(compgen -W "add remove list by" -- "$cur"))
                            ;;
                    esac
                    ;;
                track)
                    case ${words[2]} in
                        start)
                            COMPREPLY=($(compgen -W "$(_yatt_all_entities)" -- "$cur"))
                            ;;
                        list|report)
                            local entities=$(_yatt_all_entities)
                            local tags=$(_yatt_all_tags | sed 's/^/tag:/')
                            COMPREPLY=($(compgen -W "$entities $tags" -- "$cur"))
                            ;;
                    esac
                    ;;
                task)
                    case ${words[2]} in
                        create|list)
                            COMPREPLY=($(compgen -W "$(_yatt_all_entities)" -- "$cur"))
                            ;;
                        update)
                            COMPREPLY=($(compgen -W "$(_yatt_all_entities)" -- "$cur"))
                            ;;
                    esac
                    ;;
                backup)
                    case ${words[2]} in
                        restore)
                            COMPREPLY=($(compgen -W "$(_yatt_backups)" -- "$cur"))
                            ;;
                    esac
                    ;;
            esac
            ;;
        4)
            case ${words[1]} in
                project)
                    case ${words[2]} in
                        tags)
                            case ${words[3]} in
                                add|remove|list)
                                    COMPREPLY=($(compgen -W "$(_yatt_all_entities)" -- "$cur"))
                                    ;;
                                by)
                                    COMPREPLY=($(compgen -W "$(_yatt_all_tags)" -- "$cur"))
                                    ;;
                            esac
                            ;;
                    esac
                    ;;
                submodule)
                    case ${words[2]} in
                        tags)
                            case ${words[3]} in
                                add|remove|list)
                                    COMPREPLY=($(compgen -W "$(_yatt_all_entities | grep @)" -- "$cur"))
                                    ;;
                                by)
                                    COMPREPLY=($(compgen -W "$(_yatt_all_tags)" -- "$cur"))
                                    ;;
                            esac
                            ;;
                    esac
                    ;;
                task)
                    case ${words[2]} in
                        update)
                            COMPREPLY=($(compgen -W "$(_yatt_tasks "${words[3]}")" -- "$cur"))
                            ;;
                    esac
                    ;;
                track)
                    case ${words[2]} in
                        report)
                            # If previous word is an entity/tag, suggest dates
                            if [[ ${words[3]} != "" ]]; then
                                COMPREPLY=($(compgen -W "$(date +%F) $(date -d yesterday +%F)" -- "$cur"))
                            fi
                            ;;
                    esac
                    ;;
            esac
            ;;
        5)
            case ${words[1]} in
                project)
                    case ${words[2]} in
                        tags)
                            case ${words[3]} in
                                add)
                                    # For add, show all tags as suggestions
                                    COMPREPLY=($(compgen -W "$(_yatt_all_tags)" -- "$cur"))
                                    ;;
                                remove)
                                    # For remove, only show tags from the selected entity
                                    COMPREPLY=($(compgen -W "$(_yatt_entity_tags "${words[4]}")" -- "$cur"))
                                    ;;
                            esac
                            ;;
                    esac
                    ;;
                submodule)
                    case ${words[2]} in
                        tags)
                            case ${words[3]} in
                                add)
                                    # For add, show all tags as suggestions
                                    COMPREPLY=($(compgen -W "$(_yatt_all_tags)" -- "$cur"))
                                    ;;
                                remove)
                                    # For remove, only show tags from the selected submodule
                                    COMPREPLY=($(compgen -W "$(_yatt_entity_tags "${words[4]}")" -- "$cur"))
                                    ;;
                            esac
                            ;;
                    esac
                    ;;
                task)
                    case ${words[2]} in
                        update)
                            COMPREPLY=($(compgen -W "todo doing done verified" -- "$cur"))
                            ;;
                    esac
                    ;;
            esac
            ;;
    esac
}

complete -F _yatt_completion yatt
COMPLETION_EOF
}

# -------------------------------
# Help
# -------------------------------
help() {
    cat <<EOF
YATT - Yet Another Task Tracker

Usage:
  yatt <command> [subcommand] [options]

Commands:

Project management:
  project create <name> [description]                Create a new project
  project remove <name>                              Delete an existing project (asks for confirmation)
  project list                                       List projects and their submodules
  project edit <name>                                Edit project name or description  

Tag management:
  project tags add <project|module@project> <tag>    Add a tag (duplicates prevented)
  project tags remove <project|module@project> <tag> Remove a tag
  project tags list <project|module@project>         List tags of a project or submodule
  project tags by <tag>                              List all projects/submodules with the specified tag

Submodule management:
  submodule create <name>@<project> [description]    Create a submodule under a project
  submodule remove <name>@<project>                  Remove a submodule
  submodule edit <name>@<project>                    Edit submodule name or description
  submodule list <project>                           List submodules of a project with details
  submodule tags add <module@project> <tag>          Add a tag to submodule
  submodule tags remove <module@project> <tag>       Remove a tag from submodule
  submodule tags list <module@project>               List tags of a submodule
  submodule tags by <tag>                            List all submodules with the specified tag

Task management:
  task create <project|module@project>               Create a new task with interactive prompts
  task list <project|module@project>                 List all tasks for a project or submodule
  task update <project|module@project> <title> <state> Update task state (todo/doing/done/verified)

Time tracking:
  track start <project|module@project>               Start tracking time
  track stop                                         Stop the active tracking session
  track status                                       Show the currently active session with elapsed time
  track list [project|module@project]                List all tracked sessions (optional filter)
  track report [project|module@project|tag:tagname] [YYYY-MM-DD]
    Show report with optional filters:
    - No args: today's report
    - project/module: filter by project/module
    - tag:tagname: filter by tag
    - date: specific day's report
    - Any combination of filter + date

Backup management:
  backup create                                      Create a backup of all YATT data
  backup list                                        List all available backups
  backup restore <file>                              Restore data from a backup file

Shell completion:
  completion                                         Generate shell completion script

Other:
  help                                               Show this help message

Examples:
  yatt project create myapp "Main backend project"
  yatt submodule create auth@myapp "Authentication service"
  yatt project tags add myapp backend
  yatt task create myapp                            # Create a task in myapp project
  yatt task create auth@myapp                       # Create a task in auth submodule
  yatt task list myapp                              # List all tasks in myapp project
  yatt task update myapp "Setup CI" doing           # Update task state
  yatt track start myapp
  yatt track stop
  yatt track report                                  # Today's report
  yatt track report 2025-10-23                       # Specific date
  yatt track report myapp                            # All myapp entries
  yatt track report myapp 2025-10-23                 # myapp entries on specific date
  yatt track report tag:backend                      # All entries with 'backend' tag
  yatt track report tag:backend 2025-10-23           # backend tag on specific date
  yatt backup create                                 # create a backup file under ~/.yatt/backups
  yatt completion bash > /etc/bash_completion.d/yatt
EOF
}

# -------------------------------
# Project commands
# -------------------------------
project_create() {
    local name="$1"
    shift
    local desc="$*"
    local file="$PROJECTS_DIR/$name.json"

    if [[ -f "$file" ]]; then
        color_echo yellow "Project '$name' already exists."
        exit 1
    fi

    jq -n --arg n "$name" --arg d "$desc" '{name:$n, description:$d, tags:[], modules:[], tasks:[]}' > "$file"
    color_echo green "‚úÖ Project '$name' created."
}

project_remove() {
    local name="$1"

    [[ -z "$name" ]] && { color_echo red "‚ùå Usage: project remove <name>"; exit 1; }

    local project_file="$PROJECTS_DIR/${name}.json"

    if [[ ! -f "$project_file" ]]; then
        color_echo red "‚ùå Project '$name' not found."
        exit 1
    fi

    # Confirm before deletion
    read -p "‚ö†Ô∏è  Are you sure you want to delete project '$name'? (y/N): " confirm
    [[ "$confirm" =~ ^[Yy]$ ]] || { color_echo green "‚ùå Operation cancelled."; exit 0; }

    rm -f "$project_file"
    color_echo green "üóëÔ∏è  Project '$name' removed."
}

project_edit() {
    local project_name="$1"
    [[ -z "$project_name" ]] && { color_echo red "‚ùå Project name is required"; return 1; }

    local project_file="$PROJECTS_DIR/$project_name.json"
    [[ ! -f "$project_file" ]] && { color_echo red "‚ùå Project '$project_name' does not exist"; return 1; }

    local current_name
    current_name=$(jq -r '.name' "$project_file")
    local current_desc
    current_desc=$(jq -r '.description' "$project_file")

    read -p "Enter new name, empty means keep [ $current_name ]: " new_name
    read -p "Enter new description, empty means keep the old one: " new_desc

    new_name="${new_name:-$current_name}"
    new_desc="${new_desc:-$current_desc}"

    # Update JSON
    jq --arg name "$new_name" --arg desc "$new_desc" \
       '.name = $name | .description = $desc' \
       "$project_file" > "$project_file.tmp" && mv "$project_file.tmp" "$project_file"

    # Rename file if name changed
    if [[ "$new_name" != "$project_name" ]]; then
        local new_file="$PROJECTS_DIR/$new_name.json"
        if [[ -f "$new_file" ]]; then
            color_echo red "‚ùå Cannot rename: project '$new_name' already exists"
            return 1
        fi
        mv "$project_file" "$new_file"
        project_file="$new_file"
    fi

    color_echo green "‚úÖÔ∏è Project updated successfully."
    color_echo blue "   ‚Ä¢ Name: $current_name ‚Üí $new_name"
    color_echo blue "   ‚Ä¢ Description: $new_desc"

}


project_list() {
    color_echo blue "üìÇ Projects:"
    for f in "$PROJECTS_DIR"/*.json; do
        [[ -f "$f" ]] || continue
        local project
        project=$(basename "$f" .json)
        
        local desc tags
        desc=$(jq -r '.description // "No description"' "$f")
        tags=$(jq -r '.tags[]?' "$f" | tr '\n' ', ' | sed 's/,$//')
        
        color_echo purple "  üìÅ $project"
        color_echo blue "     Description: $desc"
        if [[ -n "$tags" ]]; then
            color_echo yellow "     Tags: $tags"
        else
            color_echo yellow "     Tags: (none)"
        fi
        
        local modules
        modules=$(jq -r '.modules[].name?' "$f")
        if [[ -n "$modules" ]]; then
            color_echo cyan "     Submodules:"
            while IFS= read -r m; do
                [[ -z "$m" ]] && continue
                color_echo cyan "       * $m"
            done <<< "$modules"
        fi
        echo ""
    done
}

# -------------------------------
# Submodule commands
# -------------------------------
submodule_create() {
    local full="$1"
    shift
    local desc="$*"
    local module="${full%@*}"
    local parent="${full#*@}"
    local file="$PROJECTS_DIR/$parent.json"

    if [[ ! -f "$file" ]]; then
        color_echo red "Parent project '$parent' does not exist."
        exit 1
    fi

    if jq -e --arg m "$module" '.modules[] | select(.name==$m)' "$file" >/dev/null; then
        color_echo yellow "Submodule '$module@$parent' already exists."
        exit 1
    fi

    jq --arg m "$module" --arg d "$desc" '.modules += [{"name":$m, "description":$d, "tags":[], "tasks":[]}]' "$file" \
       > "$file.tmp" && mv "$file.tmp" "$file"

    color_echo green "‚úÖ Submodule '$module@$parent' created."
}

submodule_remove() {
    local full="$1"
    local module="${full%@*}"
    local parent="${full#*@}"
    local file="$PROJECTS_DIR/$parent.json"

    [[ -f "$file" ]] || { color_echo red "Parent project '$parent' does not exist."; exit 1; }

    jq --arg m "$module" '.modules |= map(select(.name != $m))' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
    color_echo green "‚úÖ Submodule '$module@$parent' removed."
}

submodule_edit() {
    local full="${1:-}"
    [[ -z "$full" ]] && { color_echo red "‚ùå Usage: submodule edit <module@project>"; return 1; }

    local module="${full%@*}"
    local parent="${full#*@}"
    local file="$PROJECTS_DIR/$parent.json"

    # Validate project file
    [[ ! -f "$file" ]] && { color_echo red "‚ùå Parent project '$parent' does not exist."; return 1; }

    # Check module exists and grab current values
    if ! echo "$module" | grep -q .; then
        color_echo red "‚ùå Invalid module@project: $full"
        return 1
    fi

    # Get module JSON object (if it exists)
    local module_json
    module_json=$(jq -c --arg m "$module" '.modules[] | select(.name == $m)' "$file" 2>/dev/null) || true
    if [[ -z "$module_json" ]]; then
        color_echo red "‚ùå Submodule '$module' not found in project '$parent'."
        return 1
    fi

    # Extract current values
    local current_name current_desc
    current_name=$(echo "$module_json" | jq -r '.name')
    current_desc=$(echo "$module_json" | jq -r '.description // ""')

    # Interactive prompts
    read -p "Enter new name, empty means keep [ $current_name ]: " new_name
    read -p "Enter new description, empty means keep the old one: " new_desc

    # Default to old values if empty
    new_name="${new_name:-$current_name}"
    new_desc="${new_desc:-$current_desc}"

    # If name changed, ensure no other module in the project has that name
    if [[ "$new_name" != "$current_name" ]]; then
        if jq -e --arg nm "$new_name" '.modules[] | select(.name == $nm)' "$file" >/dev/null 2>&1; then
            color_echo red "‚ùå Cannot rename: a submodule named '$new_name' already exists in project '$parent'."
            return 1
        fi
    fi

    # Perform the update: update name and description for the matching module
    jq --arg old "$current_name" --arg new "$new_name" --arg desc "$new_desc" \
       '.modules = (.modules | map(if .name == $old then (.name = $new) | (.description = $desc) else . end))' \
       "$file" > "$file.tmp" && mv "$file.tmp" "$file"

    color_echo green "‚úÖ Submodule updated in project '$parent'."
    color_echo blue "   ‚Ä¢ Name: $current_name ‚Üí $new_name"
    color_echo blue "   ‚Ä¢ Description: $new_desc"
}

submodule_list() {
    local project="${1:-}"
    
    [[ -z "$project" ]] && { color_echo red "‚ùå Usage: submodule list <project>"; exit 1; }
    
    local file="$PROJECTS_DIR/$project.json"
    
    if [[ ! -f "$file" ]]; then
        color_echo red "‚ùå Project '$project' not found."
        exit 1
    fi
    
    local module_count
    module_count=$(jq '.modules | length' "$file")
    
    if [[ "$module_count" -eq 0 ]]; then
        color_echo red "üì¶ No submodules found in project '$project'."
        return 0
    fi
    
    color_echo green "üì¶ Submodules in project '$project':"
    echo ""
    
    local modules
    modules=$(jq -c '.modules[]' "$file")
    
    while IFS= read -r mod; do
        [[ -z "$mod" ]] && continue
        
        local mod_name mod_desc mod_tags
        mod_name=$(echo "$mod" | jq -r '.name')
        mod_desc=$(echo "$mod" | jq -r '.description // "No description"')
        mod_tags=$(echo "$mod" | jq -r '.tags[]?' | tr '\n' ', ' | sed 's/,$//')
        
        color_echo yellow "  üîπ $mod_name@$project"
        color_echo blue "     Description: $mod_desc"
        
        if [[ -n "$mod_tags" ]]; then
            color_echo purple "     Tags: $mod_tags"
        else
            color_echo purple "     Tags: (none)"
        fi
        echo ""
    done <<< "$modules"
}

# -------------------------------
# Task Management
# -------------------------------
task_create() {
    local target="$1"
    
    # Parse target to determine if it's a project or submodule
    local project_name module_name file
    if [[ "$target" == *@* ]]; then
        # Submodule target
        module_name="${target%@*}"
        project_name="${target#*@}"
        file="$PROJECTS_DIR/$project_name.json"
        
        # Verify project exists
        [[ ! -f "$file" ]] && { color_echo red "‚ùå Project '$project_name' does not exist."; return 1; }
        
        # Verify submodule exists
        if ! jq -e --arg m "$module_name" '.modules[] | select(.name==$m)' "$file" >/dev/null; then
            color_echo red "‚ùå Submodule '$module_name' does not exist in project '$project_name'."
            return 1
        fi
    else
        # Project target
        project_name="$target"
        file="$PROJECTS_DIR/$project_name.json"
        [[ ! -f "$file" ]] && { color_echo red "‚ùå Project '$project_name' does not exist."; return 1; }
    fi

    # Interactive prompts for task details
    read -p "Enter task title: " title
    [[ -z "$title" ]] && { color_echo red "‚ùå Task title cannot be empty."; return 1; }
    
    read -p "Enter task description (optional): " description
    
    read -p "Enter duration estimate (in hours, optional): " duration
    [[ -n "$duration" ]] && duration=$(echo "$duration * 3600" | bc)  # Convert to seconds
    
    read -p "Enter tags (comma-separated, optional): " tags_input
    local tags_array="[]"
    if [[ -n "$tags_input" ]]; then
        # Convert comma-separated string to JSON array, removing whitespace
        tags_array=$(echo "$tags_input" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | jq -R . | jq -s .)
    fi
    
    PS3="Select task state (default: todo): "
    select state in "todo" "doing" "done" "verified"; do
        break
    done
    state="${state:-todo}"

    # Create task object
    local task_json
    task_json=$(jq -n \
        --arg title "$title" \
        --arg desc "$description" \
        --arg state "$state" \
        --argjson duration "${duration:-null}" \
        --argjson tags "$tags_array" \
        '{
            title: $title,
            description: $desc,
            state: $state,
            duration: $duration,
            tags: $tags,
            created_at: (now | todate)
        }')

    # Update the project file
    if [[ "$target" == *@* ]]; then
        # Add task to submodule
        jq --arg m "$module_name" \
           --argjson task "$task_json" \
           '.modules = (.modules | map(
                if .name == $m then
                    if .tasks then .tasks += [$task]
                    else . + {tasks: [$task]}
                    end
                else .
                end
            ))' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
    else
        # Add task to project
        jq --argjson task "$task_json" \
           'if .tasks then .tasks += [$task] else . + {tasks: [$task]} end' \
           "$file" > "$file.tmp" && mv "$file.tmp" "$file"
    fi

    color_echo green "‚úÖ Task '$title' created for ${module_name:+submodule }'$target'."
}

task_list() {
    local target="$1"
    
    if [[ "$target" == *@* ]]; then
        # List submodule tasks
        local module="${target%@*}"
        local project="${target#*@}"
        local file="$PROJECTS_DIR/$project.json"
        
        [[ ! -f "$file" ]] && { color_echo red "‚ùå Project '$project' does not exist."; return 1; }
        
        color_echo blue "üìã Tasks for submodule '$module' in project '$project':"
        jq -r --arg m "$module" '
            .modules[] | 
            select(.name == $m) |
            .tasks[] |
            "  ‚Ä¢ \(.title) [\(.state)]" +
            if .description then "\n    Description: \(.description)" else "" end +
            if .duration then "\n    Duration: \(.duration/3600|floor)h \((.duration%3600/60)|floor)m" else "" end +
            if .tags|length > 0 then "\n    Tags: \(.tags|join(", "))" else "" end +
            "\n"
        ' "$file" 2>/dev/null || color_echo yellow "No tasks found."
    else
        # List project tasks
        local file="$PROJECTS_DIR/$target.json"
        [[ ! -f "$file" ]] && { color_echo red "‚ùå Project '$target' does not exist."; return 1; }
        
        color_echo blue "üìã Tasks for project '$target':"
        jq -r '
            .tasks[] |
            "  ‚Ä¢ \(.title) [\(.state)]" +
            if .description then "\n    Description: \(.description)" else "" end +
            if .duration then "\n    Duration: \(.duration/3600|floor)h \((.duration%3600/60)|floor)m" else "" end +
            if .tags|length > 0 then "\n    Tags: \(.tags|join(", "))" else "" end +
            "\n"
        ' "$file" 2>/dev/null || color_echo yellow "No tasks found."
    fi
}

task_update_state() {
    local target="$1"
    local task_title="$2"
    local new_state="$3"
    
    local file
    if [[ "$target" == *@* ]]; then
        # Update submodule task
        local module="${target%@*}"
        local project="${target#*@}"
        file="$PROJECTS_DIR/$project.json"
        
        [[ ! -f "$file" ]] && { color_echo red "‚ùå Project '$project' does not exist."; return 1; }
        
        jq --arg m "$module" \
           --arg title "$task_title" \
           --arg state "$new_state" \
           '.modules = (.modules | map(
                if .name == $m then
                    .tasks = (.tasks | map(
                        if .title == $title then
                            .state = $state
                        else .
                        end
                    ))
                else .
                end
            ))' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
    else
        # Update project task
        file="$PROJECTS_DIR/$target.json"
        [[ ! -f "$file" ]] && { color_echo red "‚ùå Project '$target' does not exist."; return 1; }
        
        jq --arg title "$task_title" \
           --arg state "$new_state" \
           '.tasks = (.tasks | map(
                if .title == $title then
                    .state = $state
                else .
                    end
            ))' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
    fi
    
    color_echo green "‚úÖ Task '$task_title' state updated to '$new_state'."
}


# -------------------------------
# Tag commands
# -------------------------------
tags_add() {
    local key="${1:-}"
    local tag="${2:-}"
    
    [[ -z "$key" ]] && { color_echo red "‚ùå Usage: project tags add <project|module@project> <tag>"; exit 1; }
    [[ -z "$tag" ]] && { color_echo red "‚ùå Usage: project tags add <project|module@project> <tag>"; exit 1; }

    if [[ "$key" == *@* ]]; then
        # Submodule
        local module="${key%@*}"
        local parent="${key#*@}"
        local file="$PROJECTS_DIR/$parent.json"
        [[ -f "$file" ]] || { color_echo red "Parent project '$parent' does not exist"; exit 1; }

        local json
        json=$(json_read "$file")

        # Prevent duplicate tag
        if echo "$json" | jq -e --arg m "$module" --arg t "$tag" '.modules[] | select(.name==$m) | .tags | index($t)' >/dev/null; then
            color_echo yellow "‚úÖ Tag '$tag' already present for submodule '$module@$parent'."
            return
        fi

        json=$(echo "$json" | jq --arg m "$module" --arg t "$tag" '
            .modules |= map(if .name==$m then .tags += [$t] else . end)
        ')
        json_write "$file" "$json"
        color_echo green "‚úÖ Tag '$tag' added to submodule '$module@$parent'."

    else
        # Project
        local file="$PROJECTS_DIR/$key.json"
        [[ -f "$file" ]] || { color_echo red "Project '$key' does not exist"; exit 1; }

        local json
        json=$(json_read "$file")
        if echo "$json" | jq -e --arg t "$tag" '.tags | index($t)' >/dev/null; then
            color_echo yellow "‚úÖ Tag '$tag' already present for project '$key'."
            return
        fi
        json=$(echo "$json" | jq --arg t "$tag" '.tags += [$t]')
        json_write "$file" "$json"
        color_echo green "‚úÖ Tag '$tag' added to project '$key'."
    fi
}

tags_remove() {
    local key="${1:-}"
    local tag="${2:-}"
    
    [[ -z "$key" ]] && { color_echo red "‚ùå Usage: project tags remove <project|module@project> <tag>"; exit 1; }
    [[ -z "$tag" ]] && { color_echo red "‚ùå Usage: project tags remove <project|module@project> <tag>"; exit 1; }

    if [[ "$key" == *@* ]]; then
        # Submodule
        local module="${key%@*}"
        local parent="${key#*@}"
        local file="$PROJECTS_DIR/$parent.json"
        [[ -f "$file" ]] || { color_echo red "Parent project '$parent' does not exist"; exit 1; }

        jq --arg m "$module" --arg t "$tag" '
            .modules |= map(
                if .name==$m then .tags |= map(select(. != $t)) else . end
            )
        ' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
        color_echo green "‚úÖ Tag '$tag' removed from submodule '$module@$parent'."

    else
        # Project
        local file="$PROJECTS_DIR/$key.json"
        [[ -f "$file" ]] || { color_echo red "Project '$key' does not exist"; exit 1; }

        jq --arg t "$tag" '.tags |= map(select(. != $t))' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
        color_echo green "‚úÖ Tag '$tag' removed from project '$key'."
    fi
}

tags_list() {
    local key="${1:-}"
    
    [[ -z "$key" ]] && { color_echo red "‚ùå Usage: project tags list <project|module@project>"; exit 1; }

    if [[ "$key" == *@* ]]; then
        local module="${key%@*}"
        local parent="${key#*@}"
        local file="$PROJECTS_DIR/$parent.json"
        [[ -f "$file" ]] || { color_echo red "Parent project '$parent' does not exist"; exit 1; }
        json_read "$file" | jq -r --arg m "$module" '.modules[] | select(.name==$m) | .tags[]?'
    else
        local file="$PROJECTS_DIR/$key.json"
        [[ -f "$file" ]] || { color_echo red "Project '$key' does not exist"; exit 1; }
        json_read "$file" | jq -r '.tags[]?'
    fi
}

tags_by() {
    local tag="${1:-}"
    [[ -z "$tag" ]] && { color_echo red "‚ùå Usage: tags by <tag>"; return 1; }
    color_echo green "Projects/submodules with tag '$tag':"

    for f in "$PROJECTS_DIR"/*.json; do
        [[ -f "$f" ]] || continue
        local project=$(basename "$f" .json)
        local json
        json=$(json_read "$f")

        # If project has tag
        if echo "$json" | jq -e --arg t "$tag" '.tags | index($t)' >/dev/null; then
            color_echo yellow "  - $project"
        fi

        # Check modules
        local modules
        modules=$(echo "$json" | jq -c '.modules[]?')
        while IFS= read -r mod; do
            [[ -z "$mod" ]] && continue
            if echo "$mod" | jq -e --arg t "$tag" '.tags | index($t)' >/dev/null; then
                local mod_name
                mod_name=$(echo "$mod" | jq -r '.name')
                color_echo blue "      * $mod_name@$project"
            fi
        done <<< "$modules"
    done
}

# Helper function to get tags for a project or module
get_tags_for_entity() {
    local entity="$1"
    
    if [[ "$entity" == *@* ]]; then
        # Submodule
        local module="${entity%@*}"
        local parent="${entity#*@}"
        local file="$PROJECTS_DIR/$parent.json"
        [[ -f "$file" ]] || return
        jq -r --arg m "$module" '.modules[] | select(.name==$m) | .tags[]?' "$file" 2>/dev/null
    else
        # Project
        local file="$PROJECTS_DIR/$entity.json"
        [[ -f "$file" ]] || return
        jq -r '.tags[]?' "$file" 2>/dev/null
    fi
}

# -------------------------------
# Tracking
# -------------------------------
ensure_tracking_file() {
    if [[ ! -f "$TRACK_FILE" ]]; then
        echo '{"active_session": null, "sessions": []}' > "$TRACK_FILE"
    fi
}

track_start() {
    local name="${1:-}"
    [[ -z "$name" ]] && { color_echo red "‚ùå Usage: yatt track start <project|module@project>"; return 1; }

    ensure_tracking_file

    # Check if active session exists
    local active
    active=$(jq -r '.active_session' "$TRACK_FILE" 2>/dev/null)
    
    if [[ "$active" != "null" ]]; then
        color_echo red "‚ùå A session is already active. Stop it first with 'yatt track stop'."
        return 1
    fi

    # Check if project/module exists
    local project_file
    if [[ "$name" == *@* ]]; then
        local parent="${name#*@}"
        project_file="$PROJECTS_DIR/${parent}.json"
        [[ ! -f "$project_file" ]] && { color_echo red "‚ùå Project '$parent' not found."; return 1; }
    else
        project_file="$PROJECTS_DIR/${name}.json"
        [[ ! -f "$project_file" ]] && { color_echo red "‚ùå Project '$name' not found."; return 1; }
    fi

    local start_time
    start_time=$(date -Iseconds)

    # Get tags for the entity
    local tags_array
    tags_array=$(get_tags_for_entity "$name" | jq -R -s -c 'split("\n") | map(select(length > 0))')
    [[ -z "$tags_array" || "$tags_array" == "[]" ]] && tags_array="[]"

    # Update tracking file with active session using jq
    jq --arg name "$name" --arg start "$start_time" --argjson tags "$tags_array" \
        '.active_session = {name: $name, start: $start, tags: $tags}' \
        "$TRACK_FILE" > "$TRACK_FILE.tmp" && mv "$TRACK_FILE.tmp" "$TRACK_FILE"

    color_echo green "‚ñ∂Ô∏è  Tracking started for '$name' at $start_time"
}

track_stop() {
    ensure_tracking_file

    # Read the active session
    local active
    active=$(jq -r '.active_session' "$TRACK_FILE" 2>/dev/null)

    # If no active session
    if [[ "$active" == "null" ]]; then
        color_echo red "‚ùå No active session to stop."
        return 1
    fi

    # Extract session details
    local name start_time tags_json end_time
    name=$(jq -r '.active_session.name' "$TRACK_FILE")
    start_time=$(jq -r '.active_session.start' "$TRACK_FILE")
    tags_json=$(jq -c '.active_session.tags' "$TRACK_FILE")
    end_time=$(date -Iseconds)

    # Calculate elapsed seconds
    local start_epoch now_epoch elapsed
    start_epoch=$(date -d "$start_time" +%s)
    now_epoch=$(date +%s)
    elapsed=$(( now_epoch - start_epoch ))

    # Extract date for the session
    local session_date
    session_date=$(date -d "$start_time" +%F)

    # Create new session entry and update tracking file
    jq --arg name "$name" \
       --arg start "$start_time" \
       --arg end "$end_time" \
       --arg date "$session_date" \
       --argjson elapsed "$elapsed" \
       --argjson tags "$tags_json" \
        '.sessions += [{name: $name, start: $start, end: $end, date: $date, duration_seconds: $elapsed, tags: $tags}] | .active_session = null' \
        "$TRACK_FILE" > "$TRACK_FILE.tmp" && mv "$TRACK_FILE.tmp" "$TRACK_FILE"

    color_echo green "‚úÖ Stopped tracking '$name'. Duration: $(format_seconds $elapsed)"
}

track_status() {
    ensure_tracking_file

    # Extract the 'active_session' object
    local active
    active=$(jq -r '.active_session' "$TRACK_FILE" 2>/dev/null)

    # If no active session
    if [[ "$active" == "null" ]]; then
        color_echo blue "üü¢ No active tracking session."
        return 0
    fi

    # Extract name and start timestamp
    local name start_time
    name=$(jq -r '.active_session.name' "$TRACK_FILE")
    start_time=$(jq -r '.active_session.start' "$TRACK_FILE")

    # Convert start_time to epoch
    local start_epoch now_epoch elapsed
    start_epoch=$(date -d "$start_time" +%s 2>/dev/null) || {
        color_echo red "‚ùå Invalid start timestamp: $start_time"
        return 1
    }
    now_epoch=$(date +%s)
    elapsed=$(( now_epoch - start_epoch ))

    local h=$((elapsed / 3600))
    local m=$(( (elapsed % 3600) / 60 ))
    local s=$((elapsed % 60))

    color_echo blue "‚è≥ Tracking: $name"
    color_echo green "   Started:  $start_time"
    color_echo yellow "   Elapsed:  ${h}h ${m}m ${s}s"
}

track_list() {
    ensure_tracking_file
    
    local filter="${1:-}"
    local sessions
    sessions=$(jq -c '.sessions[]' "$TRACK_FILE" 2>/dev/null)
    
    if [[ -z "$sessions" ]]; then
        color_echo yellow "No tracking sessions found."
        return 0
    fi

    color_echo blue "üìã Tracking Sessions:"
    echo ""

    while IFS= read -r session; do
        [[ -z "$session" ]] && continue
        
        local name start end duration date
        name=$(echo "$session" | jq -r '.name')
        
        # Apply filter if provided
        if [[ -n "$filter" && "$name" != "$filter" ]]; then
            continue
        fi
        
        start=$(echo "$session" | jq -r '.start')
        end=$(echo "$session" | jq -r '.end')
        duration=$(echo "$session" | jq -r '.duration_seconds')
        date=$(echo "$session" | jq -r '.date')

        color_echo cyan "  üìå $name ($date)"
        color_echo green "     Start: $start"
        color_echo yellow "     End: $end"
        color_echo purple "     Duration: $(format_seconds $duration)"
        echo ""
    done <<< "$sessions"
}

track_report() {
    ensure_tracking_file
    
    local arg1="${1:-}"
    local arg2="${2:-}"
    local filter_entity=""
    local filter_tag=""
    local date_filter=""
    
    # Parse arguments
    # Check if arg1 is a date (YYYY-MM-DD format)
    if [[ "$arg1" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
        date_filter="$arg1"
    elif [[ "$arg1" == tag:* ]]; then
        filter_tag="${arg1#tag:}"
        if [[ "$arg2" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
            date_filter="$arg2"
        fi
    elif [[ -n "$arg1" ]]; then
        filter_entity="$arg1"
        if [[ "$arg2" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
            date_filter="$arg2"
        fi
    fi
    
    # Default to today if no date specified
    [[ -z "$date_filter" ]] && date_filter=$(date +%F)
    
    local sessions
    sessions=$(jq -c '.sessions[]' "$TRACK_FILE" 2>/dev/null)
    
    if [[ -z "$sessions" ]]; then
        color_echo yellow "No tracking sessions found."
        return 0
    fi

    # Build report header
    local header="üìÖ Report for $date_filter"
    if [[ -n "$filter_entity" ]]; then
        header="$header (filtered by: $filter_entity)"
    elif [[ -n "$filter_tag" ]]; then
        header="$header (filtered by tag: $filter_tag)"
    fi
    color_echo blue "$header"
    echo ""

    declare -A totals
    local found_any=false

    while IFS= read -r session; do
        [[ -z "$session" ]] && continue
        
        local name start date duration tags_json
        name=$(echo "$session" | jq -r '.name')
        date=$(echo "$session" | jq -r '.date')
        duration=$(echo "$session" | jq -r '.duration_seconds')
        tags_json=$(echo "$session" | jq -c '.tags')
        
        # Filter by date
        [[ "$date" != "$date_filter" ]] && continue
        
        # Filter by entity if specified
        if [[ -n "$filter_entity" && "$name" != "$filter_entity" ]]; then
            continue
        fi
        
        # Filter by tag if specified
        if [[ -n "$filter_tag" ]]; then
            local has_tag=false
            while IFS= read -r tag; do
                if [[ "$tag" == "$filter_tag" ]]; then
                    has_tag=true
                    break
                fi
            done < <(echo "$tags_json" | jq -r '.[]?')
            [[ "$has_tag" == false ]] && continue
        fi
        
        found_any=true
        totals["$name"]=$(( ${totals["$name"]:-0} + duration ))
    done <<< "$sessions"

    if [[ "$found_any" == false ]]; then
        color_echo yellow "No entries found for the specified criteria."
        return 0
    fi

    # Display totals
    local total_sec=0
    for name in "${!totals[@]}"; do
        local d=${totals[$name]}
        total_sec=$((total_sec + d))
        color_echo green "  ‚Ä¢ $name: $(format_seconds $d)"
    done
    
    echo ""
    color_echo cyan "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    color_echo cyan "Total time: $(format_seconds $total_sec)"
}

# -------------------------------
# Backup commands
# -------------------------------
BACKUP_DIR="$YATT_DIR/backups"
mkdir -p "$BACKUP_DIR"

backup_create() {
    local timestamp
    timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="$BACKUP_DIR/yatt_backup_$timestamp.tar.gz"

    tar -czf "$backup_file" -C "$HOME" ".yatt"
    color_echo green "‚úÖ Backup created: $backup_file"
}

backup_list() {
    color_echo blue "üì¶ Available backups:"
    if compgen -G "$BACKUP_DIR/*.tar.gz" > /dev/null; then
        for file in "$BACKUP_DIR"/*.tar.gz; do
            color_echo yellow "  - $(basename "$file")"
        done
    else
        color_echo yellow "No backups found."
    fi
}

backup_restore() {
    local file="$1"
    [[ -z "$file" ]] && { color_echo red "‚ùå Usage: backup restore <backup_file>"; return 1; }
    local backup_file="$BACKUP_DIR/$file"

    if [[ ! -f "$backup_file" ]]; then
        color_echo red "‚ùå Backup file '$file' not found in $BACKUP_DIR"
        return 1
    fi

    read -p "‚ö†Ô∏è  This will overwrite your current YATT data. Continue? (y/N): " confirm
    [[ "$confirm" =~ ^[Yy]$ ]] || { color_echo green "‚ùå Restore cancelled."; return 0; }

    tar -xzf "$backup_file" -C "$HOME"
    color_echo green "‚úÖ Backup restored from '$file'"
}

# -------------------------------
# Main
# -------------------------------
main() {
    [[ $# -eq 0 ]] && { help; exit 0; }

    local cmd="$1"; shift || true
    case "$cmd" in
        help|-h|--help)
            help
            ;;

        completion)
            generate_completion
            ;;

        project)
            local sub="$1"; shift || true
            case "$sub" in
                create)
                    local target="$1"
                    shift
                    project_create "$target" "$@"
                    ;;
                remove)
                    project_remove "$@"
                    ;;
                edit)
                    project_edit "$@"
                    ;;
                list)
                    project_list
                    ;;
                tags)
                    local tagcmd="$1"; shift || true
                    case "$tagcmd" in
                        add)
                            tags_add "$@"
                            ;;
                        remove)
                            tags_remove "$@"
                            ;;
                        list)
                            tags_list "$@"
                            ;;
                        by)
                            tags_by "$@"
                            ;;
                        *)
                            color_echo red "‚ùå Unknown tag command: $tagcmd"
                            help
                            ;;
                    esac
                    ;;
                *)
                    color_echo red "‚ùå Unknown project subcommand: $sub"
                    help
                    ;;
            esac
            ;;

        task)
            local sub="$1"; shift || true
            case "$sub" in
                create)
                    [[ $# -eq 0 ]] && { color_echo red "‚ùå Usage: task create <project|module@project>"; exit 1; }
                    task_create "$@"
                    ;;
                list)
                    [[ $# -eq 0 ]] && { color_echo red "‚ùå Usage: task list <project|module@project>"; exit 1; }
                    task_list "$@"
                    ;;
                update)
                    [[ $# -lt 3 ]] && { color_echo red "‚ùå Usage: task update <project|module@project> <task_title> <new_state>"; exit 1; }
                    local target="$1"
                    local title="$2"
                    local state="$3"
                    task_update_state "$target" "$title" "$state"
                    ;;
                *)
                    color_echo red "‚ùå Unknown task subcommand: $sub"
                    help
                    ;;
            esac
            ;;

        track)
            local sub="$1"; shift || true
            case "$sub" in
                start) track_start "$@" ;;
                stop) track_stop ;;
                status) track_status ;;
                list) track_list "$@" ;;
                report) track_report "$@" ;;
                *) help ;;
            esac
            ;;

        backup)
            local sub="$1"; shift || true
            case "$sub" in
                create) backup_create ;;
                list) backup_list ;;
                restore) backup_restore "$@" ;;
                *) show_help ;;
            esac
            ;;

        submodule)
            local sub="$1"; shift || true
            case "$sub" in
                create)
                    local target="$1"
                    shift
                    submodule_create "$target" "$@"
                    ;;
                remove)
                    submodule_remove "$@"
                    ;;
                edit)
                    submodule_edit "$@"
                    ;;
                list)
                    submodule_list "$@"
                    ;;
                tags)
                    local tagcmd="$1"; shift || true
                    case "$tagcmd" in
                        add)
                            tags_add "$@"
                            ;;
                        remove)
                            tags_remove "$@"
                            ;;
                        list)
                            tags_list "$@"
                            ;;
                        by)
                            tags_by "$@"
                            ;;
                        *)
                            color_echo red "‚ùå Unknown tag command: $tagcmd"
                            help
                            ;;
                    esac
                    ;;
                *)
                    color_echo red "‚ùå Unknown submodule subcommand: $sub"
                    help
                    ;;
            esac
            ;;
        
        *)
            color_echo red "‚ùå Unknown command: $cmd"
            help
            ;;
    esac
}

main "$@"